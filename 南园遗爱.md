## 排序算法

### 冒泡排序和插入排序

~~~c++
#include<iostream>
using namespace std;
int arr[10] = {7, 4, 67, 345, -354, 0, 34, 48, -48, 48};
int n = 10;
void tmp(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
    return ;
}
// 都是正序排列
void bubble_sort(){
    for (int i = 0; i < n; i ++){
        bool flag = true;
        for (int j = 1; j < n - i; j ++){
            if (arr[j] < arr[j - 1]){
                flag = false;
                tmp(arr[j], arr[j - 1]);
            }
        }
        if (flag == true) break;
    }
    return ;
}
void insert_sort(){
    if (n <= 1) return ; // 小于等于一个元素时， 就直接因为有序而返回。
    for (int i = 1; i < n; i ++){
        int num = arr[i];
        int j = i - 1;
        for (; j >= 0; j --){
            if (arr[j] > num){
                arr[j + 1] = arr[j];
            } else {
                break;
            }
        }
        arr[j + 1] = num;
    }
    return ;
}
int main(){
    // bubble_sort();
    insert_sort();
    for (int i = 0; i < 10; i ++){
        cout << arr[i] << ' ';
    }
    puts("");
    return 0;
}
~~~



### 快速排序

~~~c++
#include<iostream>
#include<vector>

using namespace std;

const int N = 1e5 + 7;
vector<int>arr({1,3,4,5,235,234,634,7,876,235,41,-21,1,-142,-15415});

int get_partition(vector<int>&arr, int l, int r) {
    int key = 0;
    int mid = l + ((r - l) >> 1);
    if (arr[l] <= arr[mid]) {
        if (arr[mid] <= arr[r]) key = mid;
        else if (arr[mid] > arr[r]) {
            if (arr[l] <= arr[r]) key = r;
            else key = l;
        }
    } else if (arr[l] > arr[mid]) {
        if (arr[r] >= arr[l]) key = l;
        else if (arr[r] < arr[l]) {
            if (arr[r] >= arr[mid]) key = r;
            else key = mid;
        }
    }
    return key;
}

void quick_sort(vector<int>&arr, int l, int r)
{
    if (l >= r) return ;
    
    int i = l - 1, j = r + 1, mid = arr[get_partition(arr, l, r)];
    
    while (i < j)
    {
        do i ++; while (mid > arr[i]);
        do j --; while (mid < arr[j]);
        
        if (i < j) swap(arr[i], arr[j]);
    }
    
    quick_sort(arr, l, j);
    quick_sort(arr, j + 1, r);
}

int main()
{
    quick_sort(arr, 0, 14);
    for (int i = 0; i < 14; ++ i) cout << arr[i] << ' ';
    return 0;
}


~~~

快速选择：

~~~c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int size = nums.size();
        return quick_search(nums, 0, size - 1, k);
    }
private:
    // get a random num to split the array
    int partition(vector<int>& nums, int l, int r) {
        int random = rand() % (r - l + 1) + l;
        // cout << "random:" << random << endl;
        return random;
    }
    int quick_search(vector<int>& nums, int l, int r, int k) {
        int random = partition(nums, l, r);
        swap(nums[r], nums[random]);
        int j = l - 1;
        for (int i = l; i < r; ++ i) {
            if (nums[i] > nums[r]) swap(nums[++ j], nums[i]);
        }
        swap(nums[++ j], nums[r]);
        if (j == k - 1) return nums[j];
        if (j < k - 1) return quick_search(nums, j + 1, r, k);
        return quick_search(nums, l, j - 1, k);
    }
};
~~~



### 归并排序

归并排序还可以用来求数列的逆序对数。做法在注释里显示出来了。

~~~c++
#include<iostream>

using namespace std;

const int N = 1e5 + 7;
int n;
int arr[N], tmp[N];

void merge_sort(int l, int r)
{
    if (l >= r) return ;
    int mid = (l + r) >> 1;
    merge_sort(l, mid), merge_sort(mid + 1, r);
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r)
    {
        if (arr[i] <= arr[j]) tmp[++ k] = arr[i ++];
        else tmp[++ k] = arr[j ++];
    }
    while (i <= mid) tmp[++ k] = arr[i ++];
    while (j <= r) tmp[++ k] = arr[j ++];
    
    for (int i = l, j = 1; i <= r; i ++, j ++) arr[i] = tmp[j];	
}

int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++) scanf("%d",&arr[i]);
    merge_sort(1, n);
    for (int i = 1; i <= n; i ++) printf("%d ",arr[i]);
    return 0;
}
~~~

### 堆排序

~~~c++
#include<iostream>

using namespace std;

int p[9] = {0, 1, 123, -124, 3, 78, 87, -2147483648, 2147483647};
int n = 8;

void down(int u, int size) {
    int t = u;
    if (u * 2 <= size && p[u * 2] > p[t]) t = u * 2;
    if (u * 2 + 1 <= size && p[u * 2 + 1] > p[t]) t = u * 2 + 1;
    
    if (u != t) // 如果u的儿子比u小,那么交换他们，并且将换下去的元素down()一遍
    {
        swap(p[u], p[t]);
        down(t, size);
    }
}

void heap_sort(int p[], int size) {
    for (int i = size >> 1; i > 0; -- i) {
        down(i, size);
    }
    for (int i = size; i > 1; -- i) {
        swap(p[1], p[i]);
        down(1, i - 1);
    }
}

int main()
{
    heap_sort(p, n); // [1, n]
    for (int i = 1; i <= n; i ++) cout << p[i] << ' ';
    return 0;
}
~~~

### 基数排序

~~~c++
#include<iostream>
#include<cstring>

using namespace std;

const int N = 1e5 + 7;
int arr[N] = {0, 8252, 8, 72345, 645, 55, 4234, 3235 , 26346, 12};
int n = 10;

int get_max_bit(int arr[], int n){
    int digit = 1;
    int max_num = arr[0];
    for (int i = 1; i < n; i ++){
        if (arr[i] > max_num) max_num = arr[i];
    }
    while (max_num != 0){
        max_num /= 10;
        digit ++;
    }
    return digit;
}

void bit_sort(int arr[], int n) {
    int digit = get_max_bit(arr, n);
    int bit[10] = {0};
    int base = 1;
    int tmp[n] = {0};
    while(digit --){
        memset(bit, 0, sizeof(bit));
        for (int i = 0; i < n; i ++){ // 确定本次循环到的数位上，每个桶内需要装入的元素个数。
            bit[arr[i] / base % 10] ++;
        }
        for (int i = 1; i < 10; i ++){ // 求前缀和，便于运算。
            bit[i] += bit[i - 1];
        }
        for (int i = n - 1; i >= 0; i --){ // 在之前的基础上，倒序给每个数据确定本次排序的位置。
            int k = arr[i] / base % 10; /
            tmp[bit[k] - 1] = arr[i];
            bit[k] --;
        }
        for (int i = 0; i < n; i ++){
            arr[i] = tmp[i];
        }
        base *= 10;
    }
    return ;
}

int main(){
    // puts("分别输入数组的元素个数，以及所有元素");
    // cin >> n;
    // for (int i = 0; i < n; i ++){
    //     cin >> arr[i];
    // }
    bit_sort(arr, n);
    for (int i = 0; i < n; i ++){
        cout << arr[i] << ' ';
    }
    puts("");
    return 0;
}
~~~



## 动态规划

动态规划是求解多阶段决策过程最优化的方法。

这是动态规划的思考过程：确定维数，状态表示，状态计算。



### 背包问题

#### 01背包

题目描述：给定背包体积和物品数目，以及每件物品的体积和价值，每件物体只有一件。求在不超过背包体积的前提下最大价值是多少。

~~~c++
// 无优化版
#include<iostream>
using namespace std;
const int N = 1007;
int n, m;
int ans[N][N];
int v[N], w[N];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++) scanf("%d%d", &v[i], &w[i]);
    
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
	{
            ans[i][j] = ans[i - 1][j];
            if (j >= v[i]) ans[i][j] = max(ans[i][j], ans[i - 1][j - v[i]] + w[i]);
        }
    
    cout << ans[n][m] << endl;
    return 0;
}

// 优化版本
#include<iostream>
using namespace std;

const int N = 1007;
int n, m;
int ans[N];
int v[N], w[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++) scanf("%d%d", &v[i], &w[i]);
    
    for (int i = 1; i <= n; i ++)
        for (int j = m; j >= v[i]; j --)
            ans[j] = max(ans[j], ans[j - v[i]] + w[i]);
        
    cout << ans[m] << endl;
    return 0;
}
~~~

总结：两层循环n,m。加上状态转移方程。要注意优化后 m 的循环是倒着的，因为状态转移是需要使用每个状态前面的数据，而后面的数据就没用，所以可以倒着循环将其覆盖。

#### 完全背包

就是每件物品有无数件。

~~~c++
// 无优化版本
#include<iostream>

using namespace std;

const int N = 1007;
int n, m;
int ans[N][N];
int v[N], w[N];

int main()
{
    cin >> n >> m;
    
    for (int i = 1; i <= n; i ++) scanf("%d%d", &v[i], &w[i]);
    
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
                for (int k = 0; k <= m / v[i]; k ++)
                if ( k * v[i] <= j) ans[i][j] = max(ans[i][j], ans[i - 1][j - k * v[i]] + k * w[i]);
    			// 这个没有 ans[i][j] = ans[i - 1][j]; 原因是循环中当k = 0时，就实现了这个操作。
    cout << ans[n][m] << endl;
    
    return 0;
}
// 思路很简单，3层循环分别是装的物体种类，装的体积，以及比起01背包多出来的装第i件物品的件数（0 ~ m / v[i]）

// 优化版

#include<iostream>

using namespace std;

const int N = 1007;
int n, m;
int ans[N];
int v[N], w[N];

int main()
{
    cin >> n >> m;
    
    for (int i = 1; i <= n; i ++) scanf("%d%d", &v[i], &w[i]);
    
    for (int i = 1; i <= n; i ++)
        for (int j = v[i]; j <= m; j ++)
            ans[j] = max(ans[j], ans[j - v[i]] + w[i]);
    
    cout << ans[m] << endl;
    
    return 0;
}
// 这个和01背包的优化版相似，但是体积的循环方向相反。 正是如此，每个状态都对应着一维v数组中当前状态的上一个状态。也就是说求ans[i]的时候用的是ans[i - 1]。
// 完美符合这道题的逻辑。我总觉得这个是碰巧的。不然背包问题怎么可能有如此完美的相似性。
~~~

#### 多重背包

就是物品数量给定了限制数目。

~~~c++
#include<iostream>
using namespace std;
const int N = 107;
int n, m;
int s[N], v[N], w[N];
int ans[N][N];
int main()
{
    cin >> n >> m;
    
    for (int i = 1; i <= n; i ++) scanf("%d%d%d", &v[i], &w[i], &s[i]);
    
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
            for (int k = 0; k <= s[i]; k ++) // 要注意 k 要从 0 开始循环， 不然就是每种物品最少取一件了
                if (k * v[i] <= j)
                ans[i][j] = max(ans[i][j], ans[i - 1][j - k * v[i]] + k * w[i]);
    cout << ans[n][m] << endl;
    
    return 0;
}

// 优化版本
// 采用了二进制优化，就是将每种物品按二进制数目分成堆，然后当作01背包来做。
#include<iostream>
using namespace std;
const int M = 2007, N = 12000; // N 值的确定需要计算 就是物品总数乘以以2为底物品数目的对数。
int n, m;
int v[N], w[N], cnt;
int p[M];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++)
    {
        int V, W, S;
        scanf("%d%d%d", &V, &W, &S);
        int k = 1;
        while(k <= S)
        {
            cnt ++;
            v[cnt] = k * V, w[cnt] = k * W;
            S -= k;
            k *= 2;
        }
        if (S > 0) v[++ cnt] = S * V, w[cnt] = S * W; // 可能会有剩余
    }
    for (int i = 1; i <= cnt; i ++)
        for (int j = m; j >= v[i]; j --)
            p[j] = max(p[j], p[j - v[i]] + w[i]); // 01背包
    cout << p[m] << endl;
    return 0;
}
~~~

总结一下：2进制优化用于那些数据过大时的情况。普通情况用优化前的版本即可。

2进制优化是一种思想，不仅仅是一种方法。将原来一堆一个物品通过2进制优化来达到，多个物品一堆。从而减少了运算量。

在快速幂中也有一个2进制优化，这种优化分出的堆数少，不过分出的所有堆不一定能凑出1~max，之间的任何数字。对那些需要用到1~max中所有数的运算不适用，而对只用达到总数max的运算很是适用。

#### 分组背包

给定 k 组物品每组中最多只能选1个

~~~c++
#include<iostream>
using namespace std;
const int N = 107;
int n, m;
int p[N], v[N], w[N];
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++)
    {
        int s;
        cin >> s;
        for (int j = 1; j <= s; j ++) cin >> v[j] >> w[j];
        
        for (int j = m; j >= 1; j --)
            for (int k = 1; k <= s; k ++)
                if (j >= v[k])
                    p[j] = max(p[j], (p[j - v[k]] + w[k]));
    }
    cout << p[m] << endl;
    return 0;
}
// 根据题意，每层i循环，都只需要用到当前这一层的w,v。所以可以覆盖输入。
~~~

### 线性Dp

#### 数字三角形

总结一下：就是给定半个矩阵，然后在矩阵中找到一条路，使这条路上的数字和最大。其中，一个数字只能走向其正下方元素以及正下方元素右边的那一个元素。

首先是状态表示，我直接用一维来做的。p[j] 表示从最顶层到第 i 行中第 j 个元素的最大路径数字和。

其次是状态转移，p[j] = arr[i] [j] + max(p[j], p[j - 1]); 第i行的第j个元素，的最大路径数字和，是这个数字加上上一行中能走到它的两个点的最大路径数字和。（因为用到的是上一层的状态所以 j 循环需要倒着来。

最后的最大路径数字和为p[1~i]中的最大值。

~~~c++
#include<iostream>
using namespace std;
const int N = 507, INF = -1007;
int n;
int arr[N][N];
int p[N];
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= i; j ++)
            scanf("%d", &arr[i][j]);
    p[1] = arr[1][1];
    for (int i = 2; i <= n; i ++)
        for (int j = i; j >= 1; j --)
            {
                if (j == 1) p[j] = p[j] + arr[i][j]; // 1
                else if (j == i) p[j] = p[j - 1] + arr[i][j]; // 2
                else p[j] = arr[i][j] + max(p[j - 1], p[j]); 
            } // 1，2是为了防止边界问题出现的。也可以通过初始化p[]来解决这个问题，不过我初始化了半天还是错了。 用两个if就解决了。
    int MAX = p[1];
    for (int i = 2; i <= n; i ++)
        MAX = max(MAX, p[i]);
    cout << MAX << endl;
    return 0;
}

// 从下往上走可以在arr数组里进行动态规划，而且也避免了边界问题的出现。
#include<bits/stdc++.h>
using namespace std;
const int N=510;
int f[N][N];
int n;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            cin>>f[i][j];
        }
    }
    for(int i=n;i>=1;i--){
        for(int j=i;j>=1;j--){
            f[i][j]=max(f[i+1][j],f[i+1][j+1])+f[i][j];
        }
    }
    cout<<f[1][1]<<endl;
}

~~~

#### 最长上升子序列

~~~c++
// 动态规划
#include<iostream>
#include<cstdio>
using namespace std;
const int N = 1007;
int n;
int arr[N], p[N];
int ans;
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i ++) scanf("%d", &arr[i]);
    
    for (int i = 1; i <= n; i ++)
    {
        p[i] = 1;
        for (int j = 1; j <= i; j ++)
        {
            if (arr[i] > arr[j]) p[i] = max(p[i], p[j] + 1);
        }
        ans = max(ans, p[i]);
    }
    cout << ans << endl;
    return 0;
}

#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int main(void) {
    int n; cin >> n;
    vector<int>arr(n);
    for (int i = 0; i < n; ++i)cin >> arr[i];

    vector<int>stk;//模拟堆栈
    stk.push_back(arr[0]);

    for (int i = 1; i < n; ++i) {
        if (arr[i] > stk.back())//如果该元素大于栈顶元素,将该元素入栈
            stk.push_back(arr[i]);
        else//替换掉第一个大于或者等于这个数字的那个数
            *lower_bound(stk.begin(), stk.end(), arr[i]) = arr[i];
    }
    cout << stk.size() << endl;
    return 0;
}
~~~

动态规划做法：举个栗子：

例子：3 1 2 1 8 5 6

i为5，第i个数字为8，那么以8为末尾数字的最长上升子序列为，前4个数字中小于8的数字中，以他们为末尾数字的最长上升子序列加一。

模拟堆栈做法：

模拟堆栈。

### 统计次数的动态规划

比如：2019可以被分解成若干个两两不同的素数，请问方案数有多少？

思路：2019内有cnt个素数，可以筛出来。然后用这cnt个素数去凑2019。每个素数只能用一次，且正好凑够2019。（像是01背包）        这个问题求的是方案数。

状态表示：p[i] [j] 表示用前 i 个素数去凑 j 的方案数。

动态转移方程是这样的：p[i] [j] = (p[i - 1] [j] + p[i] [j - v[i] ]) 就是 要和不要本次硬币的方案数和。 要的话就是p[i - 1] [j]。不要的话就是：p[i] [j - v[i]] 。装换成一维的是：p[j] = p[j] + p[j - v[i]]。

~~~c++
#include<iostream>
using namespace std;
typedef long long LL;
const int N = 2019;
int primes[N], cnt;
bool st[N];
LL p[N];
void get_primes(){
	for (int i = 2; i <= N; i ++){
		if (st[i] == false) primes[cnt ++] = i;
		for (int j = 0; primes[j] * i <= N; j ++){
			st[i * primes[j]] = true;
			if (i % primes[j] == 0) break;
		}
	}
	return ;
}
int main(){
	get_primes();
//	for (int i = 0; i < cnt; i ++) cout << primes[i] << ' ';
	p[0] = 1;
	
	for (int i = 0; i < cnt; i ++){
		for (int j = N; j >= primes[i]; j --){
			p[j] = (p[j] + p[j - primes[i]]);
		}
	}
	cout << p[N] << endl;
	return 0;
}
~~~

### 动态规划的实际问题：

#### 1：输入一个S串和一个T串，|S|>= |T|,问最少要修改S中的几个字母才能使S中有子序列T。

~~~c++
/*
应该是二维的 ,p[i][j].
状态表示： s串的前i个字符中最少修改 p[i][j] 次，使s中有子序列t[i~j]。
// 这里说一下字串和子序列的区别：字串必须连续，子序列不要求连续性 //
状态表示：
	初始化：当 i == j 的时候 p[i][j] = i;
		   当 i <  j 的时候 p[i][j] = inf
		   当 i >  j 的时候 p[i][j] = j
	表示：
		   if(s[i] == t[j]) p[i][j] = p[i - 1][j - 1]   // 表示本次循环到相等的两个字符，这两个相等的字符不会影响p[i]																								[j]的值。
		   else p[i][j] = min(p[i][j - 1], p[i - 1][j - 1] + 1);
		   // 表示两个字符不相等，那就在没有这两个字符影响的状态：p[i - 1][j - 1]里面加上1，来使其相等。另外如果用s的前i - 1个字符就能将t的前j个字符表示的话，就不用加上1了。 所以在这里面取min。
*/

#include<iostream>

using namesapce std;

const int N = 1007;
int p[N];

void init(){
    for (int i = 1; i <= t.length(); i ++){
        for (int j = i; j <= s.length(); j ++){
            p[j][i] = i;
        }
    }
}

int main(){
    init();
    for ()
}
~~~



## 数论

### 分解质因数：

大于1的自然数N, 都可以用唯一有限个质数相乘得出。

N = p1^a1) * p2^a2) * ... * pn^an)

求N的因子有几个的时候可以先求出它所有的质因子，然后求其组合数。——求（a1 + 1) * (a2 + 1) * (a3 + 1) *...*(an + 1)。

~~~c++
void divid(int n){
    int n1 = n;
    for (int i = 2; i * i <= n; i ++){
        while (n1 % i == 0){
            n1 /= i;
            cout << i << ' ';
        }
    }
    if (n1 != 1) cout << n1; // 在便利2~n的开方之后， 可能遇到一个大于n的开方的质数，这是他就被剩下了，需要单独的判断。
}
~~~

### 生成随机数：

~~~c++
#include<iostream>
#include<cstdlib>
#include<ctime>

using namespace std;


int main() {
    unsigned a = time(0); // 表示从1970年的某个时间到现在经过的秒数。
    cout << a << endl;
    srand(a); // 配合rand()使用，给不同的a，会使得生成的随机数不一样
    for (int i = 0; i < 100; ++ i) cout << rand() % 10 << ' ';
    return 0;
}
~~~



### 小知识：

#### i2s (int 转换为string)

~~~c++
#include<sstream>
void i2s(int a, string &s){
    stringstream ss;
    ss << a; // 将a加入字符串流ss中
    ss >> s; // q
}
// c中有一个函数叫sprintf(char* s, "%d", int a);可以将a中的内容写入中。 注意：c中没有string类型，所以s必须是char*类型的，将string转化为char*可以使用.cstr();
~~~



### 一行思维代码解决很多问题

#### 1：判断一个整数n是不是2的幂次方

如果一个整数n是2的幂次方，那么他的二进制最高位是1其他位是0。用n & (n - 1)会等于0。即：            10000000 & 01111111 = 0；

~~~c++
bool is_pow(int n)
{
	return (n & (n - 1)) == 0;
}
~~~

#### 2：找出数组中那个出现奇数次的数字（其他都是偶数次）

用异或来解决，相同数字异或为0，0与其他数字异或等于其他数字。且支持交换律。

如一组数字：1 2 3 3 3 4 4 4 1 2 4

其中3出现了3次，其他都是偶数次。 

1^2^3^3^3^4^4^4^1^2^4 = (1^1)^(2^2)^(3^3)^(4^4)^(4^4)^3 = 3

~~~C++
int num = 0;
for (int i = 0; i < n; i ++)
    num ^= arr[i];
~~~

#### 3：求n阶乘的答案后的0个数

比如5！ = 120 本题解为1

会使答案后产生0的乘积是2 * 5，当然4 * 5也可以，但是4 * 5 可以拆解成2 * 2 * 5。

n的阶乘里的2肯定比5数量多，所以就是求5的数量。

10的阶乘里的5数量 ：10 / 5 = 2

24的阶乘里的5数量 ：24 / 5 = 4

25的阶乘里的5数量 ：25 / 5 + 1 = 6 （这里25贡献了2个5）

所以 n 阶乘里5的数量 为 n / 5 + n / 25 + n / 75 ...

用递归解决：

```
int get_ten(int n)
{
	return n == 0 ? 0 : n / 5 + get_ten(n / 5);
}
```

#### 4：约瑟夫环

当n = 1的时候f(n, m) = 1

找到f(n, m),和f(n - 1, m)之间的关系之后可以用递归解决

n个人每次数m个，最后活下去的人。

n - 1个人每次数m个，最后活下去的人。

删除前：--- 删除后：

1				n - m + 1

...

m-2			n-2				

m-1			n-1

m		被删除了

m+1			1

m+2			2

...			...

n			  n - m

old			new

old = (new + m - 1) % n + 1;

~~~c++
int f(int n, int m){ // 求n个人，从第1个人开始数，每次数m个数，最后剩下的人的编号。
    if (n == 1) return 1;
    return (f(n - 1, m) + m - 1) % n + 1;// 
}
~~~



这是下标从1开始的，如果从0开始则要做相应变换。

### 二分查找加线性筛筛素数

~~~c++
#include<iostream>
using namespace std;
const int N = 1e5 + 7;
int primes[N], cnt;
bool st[N];
void get_primes()
{
	for (int i = 2; i <= N; i ++)
	{
		if (st[i] == false) primes[cnt ++] = i;	
		for (int j = 0; primes[j] * i <= N; j ++)
		{
			st[primes[j] * i] = true;
			if (i % primes[j] == 0) break;
		}
	}
}
int main()
{
	get_primes();
	int n;
	cin >> n;
	int l = 0, r = cnt - 1;
// 找到最后一个小于等于 n 的素数下标,若要找第一个大于等于 n 的数的话就要用primes[mid] >= n
	while (l < r)
	{
		int mid = (l + r + 1) / 2;
		if (primes[mid] <= n) l = mid;
		else r = mid - 1;
	}
	for (int i = 0; i <= l; i ++) printf("%d\n", primes[i]);
	return 0;
}
~~~

### 旋转数组的二分查找：

~~~c++
#include<iostream>

using namespace std;

int roll_arr_binary_search(int arr[], int n, int key){
    int l = 0, r = n - 1;
    while (l <= r) {
        int mid = (r - l) / 2 + l; // 防止溢出
        
        if (key == arr[mid]) return mid;

        if (arr[l] <= arr[mid]) { // 判断mid和翻转点的位置关系。满足此条件即表示：旋转点在中点右侧
            if (key < arr[mid] && key >= arr[l]) {    // 接下来在此条件下，判断中点和key的大小关系。 满足条件即表示：key在前一段递增的数据内。
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        } else { // 中点在旋转点左侧。
            if (key > arr[mid] && key <= arr[r]) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
    }
    return -1;
}

int main(){
    int arr[9] = {6,7,8,0,1,2,3,4,5};
    int key = 5;
    cout << roll_arr_binary_search(arr, 9, key);
    return 0;
}
/*
    7 8 9 (4) 5 6 ，6 5 4 3 (9) 8 7
    像这样的，将原本升（降）序的一组数据从某处翻转，得到的数组叫做旋转数组。括号内的数据叫做翻转点。
    如何在这样的数组中进行二分查找：(下面的分析以升序旋转数组为例)
    
*/
~~~



### 快速幂

快速幂用在快速的求 a 的 k 次方 mod p。一般情况下直接求时间复杂度会很高。这里运用了2进制优化。就是第一次先求a*a，下次求 （a * a）* (a* a)。下次求（aaaa) * (aaaa) ... 为确保数据不溢出，每次乘之后都mod p。利用位运算可以迅速地求出来 k 中是否有 2 的 n 次方。举例来说 k 的二进制为 111011101 那么 k = 2的（0 + 2 + 3 + 4 + 6 + 7 + 8）次方。那么就有了如下的精巧的代码。

~~~c++
int qmi(int a, int k, int p)
{
    int res = 1; // 返回值，开始定义为1
    while(k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1; // k >>= 1将 k 左移1位
    }
    return res % p;
}
// 快速幂里面有个坑，就是当a, k, p的值取为1 0 1的时候，答案应该是0，程序有漏洞直接输出了res的值1，应该将结果在模一个p。这样就解决了这个漏洞。
~~~

### 扩展欧几里得算法：

用来解决整数二元一次不定方程的问题：a * x + b * y = c (a,b,c全为正整数)。

gcd(a, b)为a,b的最大公约数，如果c % gcd(a, b) == 0，则存在解，反之无。

利用扩展欧几里得算法可以求出不定方程的解：

~~~c++
int exgcd(int a, int b, int &x, int &y) // 一定要记得引入的是x, y的地址。
{
	if (b == 0) {x = 1, y = 0; return a};
    int r = exgcd(b, a % b, x, y);
    int temp = y;
    y = x - (a / b) * y;
    x = temp;
    return r;
}
~~~

原理：当求到最后一层a = gcd(a, b), b = 0时。（注意：这个时候的a, b已经不是原来的a,b）了。这时：a * 1 + b * 0 = gcd(a, b, x0, y0) = a。得到 x = 1, y = 0。找到本层与上一层的关系就可以推算出x,y. 

ax + by = gcd(a, b, x, y)的下一层：bx1 + (a % b)y1 = gcd(b, a % b, x1, y1)。

而a % b = a - (a / b) * b

则 ：bx1 + (a % b)y1 = bx1 + (a - (a / b) * b)y1 =

ay1 + b(x1 - (a/b)y1) = gcd(b, a % b, x1, y1)。

得到x = y1, y = x1 - (a / b) * y1.由此得到了递推关系。

### 求逆元

逆元的定义：逆元是a的k1 / b 的k2次方mod p 的问题。这个问题的答案不是 a^k1mod p 除以 b^k2 mod p。 所以有了逆元的存在。问题变成了：a^k1mod p 乘以 b^k2 mod p的逆元。 也就是：**除以一个数再取模等同于乘以这个数的逆元再取模。**那么怎么求一个数字的逆元呢？其实不可以这么说，应该说成怎么求一个数字在模一个数字情况下的逆元？其次,我们不难得知一个数的逆元有无穷多个,但是我们只需要求得一个数的最小正整数逆元就行了。另外一个数字a在模b的情况下不一定有逆元，当且仅当正整数a,b互质使a模b存在逆元。

求法：若正整数 a, b中b为质数。 由欧拉定理得：a^(b - 1) mod b = 1 转换成：a * a^(b - 2) mod b = 1 可得a^(b - 2) 就是a模b的条件下a的逆元。 诚然，只有在b是质数时等式成立。所以可以用快速幂直接求出 a^(b - 2)。但是当a,b互质，但是b不为质数的时候就需要用到扩展欧几里得来求逆元了。

#### 快速幂求逆元

a 在mod b的条件下的逆元就是a^(b - 2) mod b;



#### 扩展欧几里得算法求逆元

~~~c++


~~~

### 求组合数

求组合数就是求从a个物品里选b个的选法种数。就是求Cab。

有四种题目，分别对应着不用的数据范围。

#### 求组合数1：直接预处理法

a,b范围很小2000 * 2000 可以直接预处理出答案。

~~~c++
#include<iostream>
using namespace std;
const int N = 2007, mod = 1e9 + 7;
int n;
int a[N][N]; // 二维数组存放Cab
void fun()
{
    for(int i = 0; i < N; i ++) // 当 i 从 1 开始循环的时候a[0][0] = 0 了， 而不是正确的1.
        for (int j = 0; j <= i; j ++)
            if (j == 0) a[i][j] = 1;
            else a[i][j] = (a[i - 1][j - 1] + a[i - 1][j]) % mod;
}

int main()
{
    fun();
    cin >> n;
    while (n --)
    {
        int x, y;
        scanf("%d%d", &x, &y);
        printf("%d\n", a[x][y]);
    }
    return 0;
}
~~~





#### 求组合数2：预处理分子分母法

a,b范围比较大直接像求组合数1那样直接预处理Cab就会爆掉。所以选择预处理a,b的阶乘，以及对应的乘法逆元。利用Cab % (1e9+7) = a! (b! * (a-b)!) % (1e9+7)。就是a! * b!的逆元 * （a-b)! 的逆元。

~~~c++
#include<iostream>
using namespace std;
typedef long long LL;
const int N = 1e5 +7, mod = 1e9 + 7;
int n;
int fact[N], infact[N]; // 分别为阶乘数组以及阶乘数组的逆元。

// 快速幂求逆元
int qmi(int a, int k, int p)
{
	int res = 1;
    while(k)
    {
        res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int main()
{
    fact[0] = infact[0] = 1; // 必须要将fact[0]以及infact[0]赋值为1。
	for (int i = 1; i < N; i ++) fact[i] = (LL)fact[i - 1] * i % mod;
    for (int i = 1; i < N; i ++) infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;
    
    cin >> n;
    while (n --)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        int t = (LL)fact[a] * infact[b] % mod * infact[a - b] % mod;
        printf("%d", t);
    }
    return 0;
}
// 时间复杂度是 O(n)的。
~~~

#### 求组合数3：卢卡斯定理

![](C:\Users\一面\Desktop\用于typora\求组合数 3.png)

卢卡斯定理：Cab % p =  C(a % p)(b % p) * C(a / p)(b / p) % p。

证明：

~~~c++
#include<iostream>
using namespace std;
typedef long long LL;
int p;
int qmi(int a, int k) // 快速幂来求逆元
{
    int res = 1;
    while(k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL) a * a % p;
        k >>= 1;
    }
    return res;
}
int C(int a, int b) // 直接求Cab
{
    int res = 1;
    for (int i = 1, j = a; i <= b; i ++, j --)
    {
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
    return res;
}
int lucas(LL a, LL b)
{
    if (a < p && b < p) return C(a, b);
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
    // a % p 以及 b % p 一定小于 p 所以直接去计算就行， 而a / p 就不一定了。
}
int main()
{
    int n;
    cin >> n;
    while (n --)
    {
        LL a, b;
        scanf("%ld%ld%d", &a, &b, &p); // 长整型的格式控制符是 “%ld”;
        printf("%d\n", lucas(a, b));
    }   
    return 0;
}
~~~



#### 求组合数4：高精度

![](C:\Users\一面\Desktop\用于typora\求组合数4.jpg)

~~~c++
#include<iostream>
#include<vector>

using namespace std;

const int N = 5000;
int primes[N], cnt;
int u[N]; // 记录每个素数的次数
bool st[N];

//线性筛素数；
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++)
    {
        if (!st[i]) primes[cnt ++] = i;
        for(int j = 0; primes[j] <= n / i; j ++)
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

//得到n！中p的次数；
int get(int n, int p)
{
    int res = 0;
    while(n)
    {
        res += n / p;
        n /= p;//n每次除以p;
    }
    return res;
}

vector<int> mul(vector<int> a, int b)
{
    vector<int> c;
    int t = 0;
    for(int i = 0; i < a.size(); i ++)
    {
        t += a[i] * b;
        c.push_back(t % 10);
        t /= 10;
    }
    while(t)
    {
        c.push_back(t % 10);
        t /= 10;
    }
    return c;
}

int main()
{
    int a, b;
    cin >> a >> b;
    
    get_primes(a);
    
    for (int i = 0; i < cnt; i ++)
    {
        int j = primes[i];
        u[i] = get(a,j) - get(b, j) - get(a - b, j);
    }
    
    vector<int> res;
    res.push_back(1);
    for (int i = 0; i < cnt; i ++)
        for (int j = 0; j < u[i]; j ++)
            res = mul(res, primes[i]);
            
    for (int i = res.size() - 1; i >= 0; i --) cout << res[i];
    
    return 0;
}
~~~

### 博弈论

#### Nim游戏

![](C:\Users\一面\Desktop\用于typora\Nim游戏.png)

~~~c++
#include<iostream>

using namespace std;

int main()
{
    int n;
    cin >> n;
    int res = 0;
    while(n --)
    {
        int x;
        cin >> x;
        res ^= x;
    }
    if (res) puts("Yes");
    else puts("No");
    return 0;
}
~~~

### 高精度

#### 高精度的存储

~~~c++
#include<iostream>
#include<cstring>

using namespace std;

const int N = 10007; // 数的最大位数
string str;
int arr[N];

int main()
{
	cin >> str; // 从第一位开始读入
    arr[0] = str.length();
    // 倒序存储
    for (int i = 1; i <= arr[0]; i ++) arr[i] = str[arr[0] - i] - '0';
    
	return 0;
}
~~~

#### 高精度比较

~~~c++
int compare(int a[], int b[]) // 若a>b返回1，a<b返回-1，a==b返回0
{
	if (a[0] < b[0]) return -1;
    else if (a[0] > b[0]) return 1;
    else
    {
		for (int i = a[0]; i >= 1; i --)
        {
            if (a[i] < b[i]) return -1;
        	if (a[i] > b[i]) return 1;
        }
        return 0;
    }
}
~~~

#### 高精度加法

~~~c++
void Plus(int a[], int b[]) // 计算a=a+b;
{
    a[0] = max(a, b);
    
    for (int i = 1; i <= a[0]; i ++)
    {
        a[i] += b[i];
        a[i + 1] += a[i] / 10;
        a[i] %= 10;
    }
    while (a[a[0] + 1] != 0) // 也可以用if，因为最多只有一个进位。
    {
        a[0] ++;
    }
}
~~~

#### 高精度减法

~~~c++
bool Minus(int a[], int b[]) // 计算 a - b，存在符号问题，所以需要用到比较函数
{
    int flag = compare(a, b[); // 以比较函数来决定以后的行为
    
    if (flag == 0)
    {
        memset(a, 0, sizeof a);
        a[0] = 1, a[1] = 0;
        return true;
    }
    else if (flag == 1)
    {
        for (int i = 1; i <= a[0]; i ++)
        {
            if (a[i] >= b[i]) a[i] -= b[i];
            else
            {
                a[i + 1] --; // 借位
                a[i] = a[i] + 10 - b[i];
            }
        }
        while(a[a[0]] == 0) a[0] --;
        return true;
    }
    else
    {
        a[0] = b[0];
        for (int i = 1; i <= b[0]; i ++)
        {
            if (b[i] >= a[i]) a[i] = b[i] - a[i];
            else
            {
                b[i + 1] --;
                a[i] = b[i] + 10 - a[i];
            }
        }
        while(a[a[0]] == 0) a[0] --;
        return false;
    }
}
~~~

#### 高精度乘单精度

~~~c++
void Mult1(int a[], int b) // 判断b是否为0， 以及b的符号。
{
    if (b == 0)
    {
        memset(a, 0, sizeof a);
        a[0] = 1, a[1] = 0;
    }
    else
	{
        for (int i = 1; i <= a[0]; i ++) a[i] *= b; // 先乘 接下来进位
    
    	for (int i = 1; i <= a[0]; i ++)
    	{
        	a[i + 1] += a[i] / 10;
        	a[i] %= 10;
    	}
        
    	int len = a[0] + 1;
    	while (a[len] != 0) // 这个操作是为了使最后一位进位
    	{
        	a[len + 1] += a[len] / 10;
        	a[len] %= 10;
        	len ++;
            a[0] ++;
    	}
    }
}
// 处理乘负数的时候再调用函数时先判断单精度数字的符号，然后进行变换
~~~

#### 高精度乘高精度

~~~c++
int c[N] = {0};

void Multi2(int a[], int b[])
{
    c[0] = a[0] + b[0];
    
    // 先乘再进位
    for (int i = 1; i <= a[0]; i ++)
    {
        for (int j = 1; j <= b[0]; j ++)
        {
             c[i + j - 1] += a[i] * b[j];
        }
    }
    for (int i = 1; i <= c[0]; i ++)
    {
        c[i + 1] += c[i] / 10;
        c[i] %= 10;
    }
    // 继续处理c[c[0]]上的溢出
    int len = c[0] + 1;
    while (c[len] != 0)
    {
        c[len + 1] += c[len] / 10;
        c[len] %= 10;
        len ++;
        c[0] ++;
    }
            
    len = c[0]; // 处理某一个数字为0时，的去前导零。
	while (c[len] == 0 && len != 1) len --;
	c[0] = len;
}
~~~

#### 高精度除法 （有没有高精度除以高精度？)

~~~c++
void Cut(int a[], int d[], int b)
{
    int tmp = 0; // 余数
    for (int i = a[0]; i > 0; i --) // 除法要正着算， 所以倒着循环
    {
    	tmp = tmp * 10 + a[i];
        if (tmp >= b)
        {
        	d[i] = tmp / b;
        	tmp %= b;
		}
    }
    while (d[a[0]] == 0) a[0] --;
    d[0] = a[0];
}
~~~

### 全排列问题

那种给出数字求出满足某种性质的这些数字的排列。常常需要用到数字的全排列，就是求出数字的全排列然后check（）一遍，把符合条件的筛选出来。

1：next_permutation(arr, arr + n);

~~~c++
#include<iostream>
#include<algorithm>

using namespace std;

int arr[3] = {1,2,3};
string s = "abc";
int main()
{
	// int类型全排列： 
	do{
		for (int i = 0; i < 3; i ++) cout << arr[i] << ' ';
	}while(next_permutation(arr, arr + 3));
	
	puts("");
	
	// string全排列：
	do{
		cout<<s<<" ";
	}while(next_permutation(s.begin(), s.end()));
	
	return 0;
}
~~~

1：next_permutation()函数在#include<algorithm>里面。

2：能对很多种类型进行全排列，以开始排列顺序向下进行按ascll码降序进行排列，到达顺序排列为按ascll码权值逆序时函数返回值为false。配合do while()使用很方便。

手写一个全排列：

思想是前面位上的数字都可以放在后面的每一位（与后面的每一位交换位置.

~~~c++
#include<iostream>
#include<algorithm>
using namespace std;
int arr[9] = {1,2,3,4,5,6,7,8,9};
int num;

void f(int n)
{
	if (n == 9) // 一种全排列已经生成 
	{
		// for (int i = 0; i < 9; ++ i) cout << arr[i] << ' ';
		num ++; // 362880
		return ;
	}
	for (int i = n; i < 9; i ++) // n往后的每个数字都可以放在第n位 
	{
		swap(arr[i], arr[n]);
		f(n + 1);
		swap(arr[i], arr[n]); // 回溯 
	}
}
int main()
{
	f(0);
	cout << num;
	return 0;
}



#include<iostream>
#include<algorithm>

using namespace std;

int arr[9] = {0, 1, 2, 3, 4, 5, 6, 7, 8};
int len = 9;
int num = 0;

void f(int n, int *arr){
    if (n == len){
        // for (int i = 0; i < len; i ++){
        //     cout << arr[i] << ' ';
        // }
        num ++; // 计数  362880
        puts("");
        return ;
    }
    for (int i = n; i < len; i ++){
        swap(arr[i], arr[n]);
        f(n + 1, arr);
        swap(arr[i], arr[n]);
    }
}
int main()
{
    f(0, arr);
    printf("%d", num);
	return 0;
}
~~~



### 区间和问题（前缀和 树状数组 线段树 ）：

快速得到一段区间的数值和，可能需要支持单点修改，区间修改等操作。

#### 1：前缀和

将数据求合，第i个数据就是前 i 个数据的和，求之间的某段数据之和时，进行相应的区间减就行。

~~~c++
// 区间和数组的求法
for (int i = 1; i <= n; i ++) scanf("%d", &sum[i]), sum[i] += sum[i - 1];
// 求出第 l~r 之间的数据之和
int get_sum(int l, int r){
	return sum[r] - sum[l - 1];
}
~~~

快速的实现了得到区间和的操作，但是可以看看单点修改操作。

~~~c++
// 将第 i 个元素修改成别的数字a：（也有一种操作是将第i个元素加上某个数字）
// 这需要先求出第i个元素的值b，然后将前缀和数组sum的第i~n项都加上b - a; 时间复杂度O(n)
// 如果是将一段区间内的数加上某个数a，就需要以O(n)的时间复杂度进行操作
int a = 2;
int sum = a;
for(int i = l; i <= n; i ++){
	arr[i] += sum;
    if(i < r) sum += a;
}
// 但如果是将一段区间内的数字变成某个数子，就需要O(n*n)的复杂度了。
~~~

可见前缀和的方法，只对查询操作有优势，但是对修改操作很无力。

#### 2：树状数组

先讲一个操作：lowbit(n) ：求整数n的二进制数，从低位到高位第一个1所在位数的权值是多少。（当然有些操作求的是第几位。）

~~~c++
inlin int lowbit(int n) {return x & (-x);} // 对于这样很短的代码，加上inline之后会变得快一些。
原数字x：1011000
-x : 将数字x的符号位变成1，然后每位都取反，最后加上1：10101000
   x:01011000
  -x:10010100
      x & -x = 1000
~~~

树状数组c，每一位 i 上存储的都是：从 i 项开始，向后数lowbit(i)项的数之和。

在将第 i 项数据加上 a 的时候只要从第

~~~c++
#include<iostream>
using namespace std;
const int N = 1e5 + 7;
int arr[N], c[N];

inline int lowbit(int x) { return x&(-x);}
// 向第ind个元素加上一个val  
void updata(int ind, int val, int n){
    while (ind <= n){
        c[ind] += val;
        ind += lowbit(ind);
    }
}
// 返回ind的前缀和值，也就是前ind个元素的和。
int query(int ind){
    int sum = 0;
    while(ind > 0){
        sum += c[ind];
        ind -= lowbit(ind);
    }
    return sum;
}
int main(){
    ios_base::synic_with_stdio(false);
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i ++){
        scanf("%d", &arr[i]);
        updata(i, arr[i], n);
    }
    int a, b, c;
    while (m --){
        cin >> a >> b >> c;
        if (a == 1) updata(b, c, n);
        else cout << querry(c) - querrt(b - 1) << endl;
    }
    return 0;
}
~~~

在单点修改上面树状数组做得很好，但是在区间修改上面它就显得力不从心了。这时候出现了线段树。

#### 3：线段树

数据段：

~~~c++
#define maxn 100007 // 元素总个数
#define ls l, m, rt << 1
#define rs m + 1, r, rt << 1 | 1
int Sum[maxn << 2], Add[maxn << 2]; // Sum求和 Add作懒标记
int A[maxn], n; // 存储原数组 下表为[1, n]
~~~

建树：

~~~c++
// PushUp函数更新节点信息，这里是求和
void PushUp(int rt){Sum[rt] = Sum[rt << 1] + Sum[rt << 1 | 1];}
// Build函数建树
void Build(int l, int r, int rt){
    if (l == r){ // 到达了子节点
        Sum[rt] = A[l];
        return ; // 这里要返回 不然会无穷递归
    }
    int m = (l + r) >> 1;
    // 左右递归
    Build(l, m, rt << 1);
    Build(m + 1, r, rt << 1 | 1);
    // 更新信息
    PushUp(rt);
}
~~~

单点修改

设A[L] += C

~~~c++
void Update(int L, int C, int l, int r, int rt){ // l, r表示当前节点区间 rt表示当前节点编号
    if (l == r){ // 终于找到了叶子节点
        Sum[rt] += C;
        return ;
    }
    int m = (l + r) >> 1;
    // 根据条件判断往左子树调用还是往右子树调用
    if (L <= m) Update(L, C, l, m, rt << 1);
    else Update(L, C, m + 1, r, rt << 1 | 1);
    PushUp(rt); // 子节点更新，父亲节也需要更新
}
~~~

区间修改

设A[L, R] += C

~~~c++
void Update(int L, int R, int C, int l, int r, int rt){
    if (L <= l && r <= R){ // 如果本次操作区间完全在[L, R]以内
        Sum[rt] += C * (r - l + 1); // 更新数字哥， 像上保持保持正确
        Add[rt] += C; // 增加Add标记，表示本区间的Sum正确，子区间的Sum仍需要根据Add的值来进行更新
        return ;
    }
    int m = (l + r) >> 1;
    // 判断左右子树跟[L, R]有无交集， 有交集才递归。
    if (L <= m) Update(L, R, C, l, m, rt << 1);
    if (R > m) Update(L, R, C, m + 1, r, rt << 1 | 1);
    PushUp(rt);
}
~~~

区间查询：

询问A[L, R]的和

~~~c++
// 首先是下推标记函数
void PushDown(int rt, int ln, int rn){
    // ln为rt的左右子树的数字数量。
    if (Add[rt]){
        // 下推标记
        Add[rt << 1] += Add[rt];
        Add[rt << 1 | 1] += Add[rt];
        // 修改子节点的Sum使之与之对应的Add项对应
        Sum[rt << 1] += Add[rt] * ln;
        Sum[rt << 1 | 1] += Add[rt] * rn;
        // 清除本结点标记
        Add[rt] = 0;
    }
}
// 然后是区间查询的函数
int Query(int L, int R, int l, int r, int rt){ // L,R表示操作区间 l,r表示当前节点区间， rt表示当前节点编号
    if (L <= l &&  r <= R){ // 在区间内直接返回
        return Sum[rt];
    }
    int m = (l + r) >> 1;
    // 需要先下推标记
    PushDown(rt, m - l + 1, r - m);
    // 累计答案
    int ANS = 0;
    if (L <= m) Ans += Query(L, R, l, m, rt << 1);
    if (R > m) ANS += Query(L, R, m + 1, r, rt << 1 | 1);
    return ANS;
}
~~~

~~~c++
// 函数调用：
// 建立一棵树
Build(1, n, 1);
Update(L, C, 1, n, 1);
Update(L, R, C, 1, n, 1);
int ANS = Query(L, R, 1, n, 1);
~~~

 线段树完整代码：

~~~c++
#include<iostream>

using namespace std;

const int N = 1e5 + 7;
int Sum[N], Add[N]; // Sum求和，Add作懒标记
int A[N] = {0,1,1,1,1,1,1,1}, n = 7;

void PushUp(int rt){
	Sum[rt] = Sum[rt << 1] + Sum[rt << 1 | 1];
}

void PushDown(int rt, int ln, int rn){
	// ln, rn分别为左右子树的子节点数量
	if (Add[rt]){ // 下推标记一下子 
		Add[rt << 1] += Add[rt];
		Add[rt << 1 | 1] += Add[rt];
		Sum[rt << 1] += Add[rt] * ln;
		Sum[rt << 1 | 1] += Add[rt] * rn;
		// 清除本结点标记
		Add[rt] = 0;
	} 
}

void Build(int l, int r, int rt){
	if (l == r){
		Sum[rt] = A[l];
		return ;
	}
	int m = (l + r) >> 1;
	Build(l, m, rt << 1);
	Build(m + 1, r, rt << 1 | 1);
	PushUp(rt);
}
// 单点修改  A[C] += B
void Update(int C, int B, int l, int r, int rt){
	if (l == r){
		Sum[rt] += B;
		return ;
	}
	int m = (l + r) >> 1;
	if (C <= m) Update(C, B, l, m, rt << 1);
	else Update(C, B, m + 1, r, rt << 1 | 1);
	PushUp(rt);
}
// 区间修改 A[x, y] += B
void Update(int x, int y, int B, int l, int r, int rt){
	if (x <= l && y >= r){ // 本次操作区间全部在[x, y]中 
		Add[rt] += B; // 懒标记一下子
		Sum[rt] +=  (r - l + 1) * B;
		return ;
	}
	int m = (l + r) >> 1;
	if (x <= m) Update(x, y, B, l, m, rt << 1);
	if (y > m) Update(x, y, B, m + 1, r, rt << 1 | 1);
	PushUp(rt);
} 

// 区间查询 A[L, R]
int Query(int L, int R, int l, int r, int rt){
	if (L <= l && R >= r){
		return Sum[rt];
	}
	int m = (l + r) >> 1;
	// 首先下推标记
	PushDown(rt, m - l + 1, r - m);
	int ANS = 0;
	if (L <= m) ANS += Query(L, R, l, m, rt << 1);
	if (R > m) ANS += Query(L, R, m + 1, r, rt << 1 | 1);
	return ANS;
} 

int main(){
	Build(1, n, 1);
	char op;
	int x, y, z;
	while (true){
		scanf("%s%d%d%d", &op, &x, &y, &z);
		if (op == 'a'){
			Update(x, y, 1, n, 1);
		} else if (op == 'b'){
			Update(x, y, z, 1, n, 1);
		} else if (op == 'c'){
			printf("%d\n", Query(x, y, 1, n, 1));
		} else if (op == 'd') {
			for (int i = 1; i <= n * 4; i ++) printf("%d ", Sum[i]);
			puts("");
		}
		
	}
	return 0;
}
~~~



### 卡特兰数列

1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012...（首项记为零项）

卡特兰数g（n）满足以下性质：

g(n + 1) = g(0) * g(n) + g(1) * g(n - 1) + ... + g(n) * g(0)

递推关系：g(n) = g(n - 1) * (4 * n - 2) / (n + 1);

递归关系的解为：g(n) = C(2n, n)/(n + 1)(n = 1,2,3,4...)

或者 g(n) = C(2n, n) - C(2n, n - 1);

有很多应用：

括号化

### 求一个集合的子集：

方法一：

假设一个集合为A = {1,2,3},那么我们用三位二进制数表示选择的集合元素下标。

| 0/1序列 | 子集    |
| ------- | ------- |
| 000     | {}      |
| 001     | {3}     |
| 010     | {2}     |
| 100     | {1}     |
| 011     | {2,3}   |
| 101     | {1,3}   |
| 110     | {1,2}   |
| 111     | {1,2,3} |

那么就可以循环 i = [ 0, 1 << n )， i 表示一个字集。i 的第 j 位为 1 表示arr[i]在这个集合中存在。

时间复杂度：O(n * 2^n)，超高时间复杂度。

~~~c++
#include<iostream>
#include<vector>

using namespace std;

vector<vector<int> >ret;

int main() {
    vector<int>arr(100, 0);
    int n = 5;
    for (int i = 0; i < n; ++ i) arr[i] = i;
    for (int i = 1; i < (1 << n); ++ i) {
        vector<int>tmp;
        for (int j = n - 1; j >= 0; j --) {
            if (i & (1 << j)) tmp.push_back(arr[j]);
        }
        ret.push_back(tmp);
    }
    for (int i = 0; i < ret.size(); ++ i) {
        for (int j = 0; j < ret[i].size(); j ++) {
            cout << ret[i][j] << ' ';
        }
        puts("");
    }
    return 0;
}
~~~

方法二：

首先对每个元素进行遍历，将其加入到现有子集中（在开始的时候，现有子集只有一个，即空集），（这里的加入不是真的加入，而是将现有子集复制到一个tmp中，然后将遍历到的元素加入tmp, 这时候tmp便是新得到的子集。）

~~~c++
class Solution {
    vector<vector<int>> res;
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        res.push_back(vector<int>());//初始子集是空集
        for(int cur = 0; cur < nums.size(); ++cur)
        {
            int size = res.size();
            for(int j = 0; j < size; ++j)
            {
                vector<int> tmp = res[j];//对于已经求出的每个子集
                tmp.push_back(nums[cur]);//将第cur个元素加入其中
                res.push_back(tmp);
            }
        }
        return res;
    }
};
~~~



## 数据结构

### 单链表

~~~c++
/*
链表的操作:
 单链表反转
 链表中环的判断
 有序链表的合并
 删除链表倒数第n个结点
 求链表中间节点
*/
~~~

#### 链表中环的判断以及其长度的计算

~~~c++
#include<iostream>

using namespace std;

struct ListNode{
    int val;
    struct ListNode *next;
    ListNode(int x) : 
        val(x), next(NULL){
        }
};

bool is_loop(ListNode* head) {
    ListNode *fast = head;
    ListNode *slow = head;
    while (fast != NULL && fast->next != NULL) {
        fast = fast->next->next;
        slow = slow->next;
        if (fast == slow) return fast;
    }
    return NULL;
}

int loop_length(ListNode* head){
	if (!is_loop(head)) return 0; // 不是环
	int len = 0;
	ListNode* fast = head;
	ListNode* slow = head;	
	bool begin = false;
	while (1){
		fast = fast->next->next;
		slow = slow->next;
		if (fast == slow && begin == true){
			break;
		} else if (fast == slow && begin == false){
			begin = true;
		} // 双指针第一次相遇，开始计数
		if (begin == true) len ++;
	}
	return len;
}
int main(){
    int arr[6] = {0, 1, 2 ,3 ,4, 5};
    ListNode* head = new ListNode(0);
    ListNode* p = head;
    // 尾插法，插入元素。
    for (int i = 1; i < 6; i ++){
        ListNode* q = new ListNode(arr[i]);
        p->next = q;
        p = p->next;
    }
    p->next = head->next;
    ListNode* m = head;
	cout << loop_length(head) << endl;
    return 0;
}
~~~

#### 反转链表：

~~~c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *prev = NULL;
        ListNode *curr = head;
        while (curr){
            ListNode *next = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};
~~~

#### 有序链表的合并：

~~~c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        ListNode *head = new ListNode(0), *cur = head;
        while (l1 && l2){
            if (l1->val >= l2->val){
                cur->next = l2;
                cur = cur->next;
                l2 = l2->next;
            } else {
                cur->next = l1;
                cur = cur->next;
                l1 = l1->next;                
            }
        }
        while (l1){
                cur->next = l1;
                cur = cur->next;
                l1 = l1->next;              
        }
        while (l2){
                cur->next = l2;
                cur = cur->next;
                l2 = l2->next;              
        }
        return head->next;
    }
};
~~~

#### 环路检测：

~~~c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *get_entrance(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        bool flag = false;
        while (fast != NULL && fast->next != NULL) {
            fast = fast->next->next;
            slow = slow->next;
            if (fast == slow) { // 快慢指针相遇，有环。
                flag = true;
                break;
            }
        }
        if (flag == false) return NULL;
        fast = head; // 一个指针从相遇点开始，另一个指针从头节点开始，两个指针每次都移动一步，相遇点便是环的入口节点。
        while (fast != slow) {
            fast = fast->next;
            slow = slow->next;
        }
        return fast;
    }
    ListNode *detectCycle(ListNode *head) {
        return get_entrance(head);
    }
};
~~~



### 并查集

~~~c++
#include<iostream>

using namespace std;

const int N = 1e5 + 7;
int parents[N], cnt[N]; // 分别保存其父节点，还有秩的大小。 秩是树的高度-1。通常称只有一个结点的树秩为0。

void init(){
    for (int i = 1; i <= n; i ++) parents[i] = i;
}

int find(int a) { // 这里有一个状态压缩， 在第一次查找的时候将每一个子节点指向根节点。
    if (parents[a] == a) return a;
    return parents[a] = find(parents[a]);
    // return a == parents[a] ? a : (parents[a] = find(parents[a]));
}

void union(int a, int b){ // 合并a,b所在的两个集合。
    int f1 = find[a];
    int f2 = find[b];
    if (f1 == f2) return ; // 两个集合已经在同一个集合中了。
    if (cnt[f1] > cnt[f2]){
        parents[f2] = parents[f1];
    }
    else {
        parents[f1] = parents[f2];
        if (cnt[f1] == cnt[f2]) cnt[f2] ++; // 高度相同，合并之后树高增加需要将秩增加1。
    }
}

~~~

### 哈希

#### 字符串哈希

~~~c++
#include<iostream>
using namespace std;
typedef unsigned long long ULL;
const int N = 1e5 + 7, P = 131;
int n, m;
char str[N];
ULL h[N], p[N]; // p数组预处理出P的i次方 mod 2^64 - 1;
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
int main()
{
    cin >> n >> m >> str + 1;
    p[0] = 1;
    for (int i = 1; i <= n; i ++)
    {
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + str[i]; // 求子串哈希值 
    }
    while (m --)
    {
        int l1, r1, l2, r2;
        scanf("%d%d%d%d", &l1, &r1, &l2, &r2);
        
        if (get(l1, r1) == get(l2, r2)) puts("Yes");
        else puts("No");
    }
    return 0;
}
~~~

### 二叉树

#### 首个公共祖先：

求二叉树中节点p，q的首个公共祖先

分两种情况：1：p(q)为根节点，q(p)为其子节点，那么首个公共祖先就是p(q)

						2：p，q都为某个节点的子节点，那么最近公共祖先就是这个节点

~~~c++
calss Solution{
public:
    ListNode* get(ListNode* root, ListNode* p, ListNode* q) {
        if (root == NULL || root == p || root == q) return root;
        ListNode* l = get(root->left, p, q);
        ListNode* r = get(root->right, p, q);
        if (l == NULL) return r;
        if (r == NULL) return l;
        return root;
    }
};
~~~



### 位图

~~~c++
#include<iostream>
#include<vector>

using namespace std;

class bitMap{
public:
    bitMap(int size_n) { // 构造函数
  
        _bits.resize((size_n >> 5) + 1);
    }

    void set(int n) { // 将数字n在位图中对应的位置1
        int cnt = n >> 5; // 相当于 n / 32
        int temp = n & 31; // 相当于 n % 32
        _bits[cnt] |= 1 << temp;
    }
    bool check(int n) { // 检查数字n是否在位图中被置1了
        int cnt = n >> 5;
        int temp = n & 31;
        if (_bits[cnt] & (1 << temp)) return true;
        return false;
    }
    void reset(int n) { // 置反
        int cnt = n >> 5;
        int temp = n & 31; 
        _bits[cnt] ^= 1 << temp;
    }

private:
    vector<unsigned int>_bits;
};

void test() {
    bitMap a(1321);
    a.set(213);
    a.set(123);
    a.reset(123);
    cout << a.check(123) << ' ' << a.check(213);
}

int main() {
    test();
    return 0;
}
~~~









### 宽度优先搜索

#### 走迷宫

~~~c++
#include<iostream>
#include<cstring>
using namespace std;
typedef pair<int ,int> PII;
const int N = 107;
int n, m;
int g[N][N]; // 地图
int ans[N][N], dir[N][N]; // 每个点到起点的距离， 存储到每个点的方向。
PII arr[N * N], record[N][N]; // 队列数组，大小为点的个数。
int dfs()
{
    memset(ans, -1, sizeof ans);
    int tt = 1, hh = 1;
    arr[hh ++] = {1, 1};
    ans[1][1] = 0;
    int dir_x[4] = {0, 0, 1, -1}, dir_y[4] = {1, -1, 0, 0};
    while(tt < hh)
    {
        PII t = arr[tt];
        tt ++;
        int x = t.first, y = t.second;
        for (int i = 0; i < 4; i ++)
        {
            int now_x = x + dir_x[i], now_y = y + dir_y[i];
            if (g[now_x][now_y] == 0 && now_x >= 1 && now_x <= n && now_y >= 1 && now_y <= m && ans[now_x][now_y] == -1) // 最后一个判断条件是走过的点就不再走了，否则会死循环。 另外走过的点再走时不会出现最短距离。
            {
                dir[now_x][now_y] = i; // 记录方向
                record[now_x][now_y] = {x, y}; // 记录路径
                ans[now_x][now_y] = ans[x][y] + 1;
                arr[hh ++] = {now_x, now_y};
            }
        }
    }
    return ans[n][m];
}

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
            scanf("%d", &g[i][j]);
    int a = dfs();
    
    PII s[a]; // 路径数组
    int cnt = a - 1;
    
    // 存储从[1,1]到[n,m]的路径。
    int x = n, y = m;
	while (x != 1 || y != 1)
	{
 	   PII t = record[x][y];
 	   s[cnt --] = {x, y};
 	   x = t.first, y = t.second;
	}
    
    // 输出方向
	for (int i = 0; i < a; i ++)
	{
	    PII t = s[i];
	    x = t.first, y = t.second;
	    switch(dir[x][y])
	    {
	        case 0: cout << "右"; break;
	        case 1: cout << "左"; break;
	        case 2: cout << "下"; break;
	        case 3: cout << "上"; break;
	    }
	    
	}
    return 0;
}
~~~

有一种题型是输出按最小字典序输出路径，如字典序（上  <  下  <  左   <  右 ) 这是只需要改变dir_x，dir_y的顺序即可。然后用record数组记录路径，得到需要走的步数之后，建立相应大小的数组，存贮需要的从[n, m]到[1, 1]的路径（record[x] [y]记录的是到x,y的点， 所以需要反演，得到路径存储起来）另外在bfs的时候需要记录到每一个点的 i 值,(也就是通过那个方向到这个点的)。每一个 i 值对应一个方向，用 switch 对应输出就好了。

## 最短路问题

### 最短路问题的图解，以及他们各自的时间复杂度。


### dijkstra算法

求无负权边的最短路算法。 数据范围比较大的时候可以用堆优化的版本来求解。

dist[i]数组存储的是1点到其他点的距离，1到1的距离为0， dist[1] = 0; 然后先更新1点到其他点的距离，并且标记1点已经走过，之后每次挑选到1点最近的点来更新其他点，并且标记此点。

~~~c++
#include<iostream>
#include<cstring>

using namespace std;

const int  N = 507;
int n, m;
int arr[N][N]; // 稀疏图， 用邻接矩阵来存储。
int dist[N];
bool st[N];

int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    for (int i = 1; i <= n; i ++)
    {
        int t = -1;
        for (int j = 1; j <= n; j ++) // 这里还有下面的更新，都是从1～n；否则会更新不到n这个点
            if (st[j] == false && (t == -1 || dist[j] < dist[t])) t = j;
            
        st[t] = true;
        
        for (int j = 1; j <= n; j ++)
            dist[j] = min(dist[j], dist[t] + arr[t][j]);
    }
    
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    memset(arr, 0x3f, sizeof arr);
    cin >> n >> m;
    
    for (int i = 1; i <= m; i ++)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        arr[a][b] = min(arr[a][b], c);
    }
    
    printf("%d", dijkstra());
    
    return 0;
}

// 堆优化版的dijkstra
#include<iostream>
#include<cstring>
#include<queue>
#include<vector>

using namespace std;

typedef pair<int, int> PII;

const int N = 1e5 + 7;
int n, m;
int h[N], e[N], ne[N], w[N], idx = 1; // 稠密图
int dist[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    priority_queue<PII, vector<PII>, greater<PII>> q; // 定义一个小根堆
    
    q.push({1, 0});
    
    while(!q.empty())
    {
        PII t = q.top();
        q.pop(), st[t];
        
        int num = t.first, length = t.second;
        
        for (int i = h[num]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > w[i] + length)
            {
                dist[j] = w[i] + length;
                q.push({j, dist[j]});
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    memset(h, -1, sizeof h);
    cin >> n >> m;
    for (int i = 1; i <= m; i ++)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    
    cout << dijkstra() << endl;
    
    return 0;
}
~~~



### bellman_ford算法

适用于存在负权边的最短路问题，时间复杂度为固定的O(mn)。这个算法有一个牛b之处就是只有他能解决那种最多经过 k 条边的最短路问题。

~~~c++
#include<iostream>
#include<cstring>

using namespace std;

const int N = 1e4 + 7, M = 507;
int n, m, k;
int dist[M], backup[M];

// bellman_ford算法对储存方式没有什么要求，用一个结构体足矣。
struct data
{
	int a, b, c;
}step[N];

int bellman_ford()
{
	memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    for (int i = 1; i <= k; i ++)
    {
        memcpy(backup, dist, sizeof dist);
        
        for (int j = 1; j <= m; j ++)
        {
            int a = step[j].a;
            int b = step[j].b;
            int c = step[j].c;
            
            dist[b] = min(dist[b], backup[a] + c);
            // 这个backup的操作是为了，不让 k 步走不到的点来影响操作
        }
    }
    /*	这个if 里的内容是因为，当到不了 n 点时，这个点的距离可能会被其他负权点更新过， 就会小于4^（0x3f)了
    但是最小也就是 边长的边长最小值（-1000）* （N - 1）(最多的边长数减一) = 1e6  描述一下这种情况的一种吧！就是第一个1点无法到第二个点，而其他边都是到 n 点的距离为 -1000。 这种情况下，dist[n] = m(0x3f) - 1e6 > m(0x3f) / 2	*/
    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}

int main()
{
    cin >> n >> m >> k;
    
    for (int i = 1; i <= m; i ++)
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        step[i] = {a, b, c};
	}
    
    int t = bellman_ford();
    
    if (t == -1) puts("impossible");
    else cout << t << endl;
    
    return 0;
}
~~~

### spfa算法

用于存在负权边的最短路问题，是bellman_ford算法的优化。时间复杂度一般为O(m)，最坏与bellman相同为O(mm).优化的点在于bellman算法的松弛操作是将所有边遍历，其中包含了大量不必要的边。优化就在于将最短距离被更新过的点进入队列用这些点去更新别的点。（没被更新过的点用来更新别的点是没有作用的）

~~~c++
#include<iostream>
#include<queue>
#include<cstring>

using namespace std;

const int N = 1e5 + 7;
int m, n;
int h[N], ne[N], e[N], w[N], idx;
int dist[N], cnt[N];
bool bt[N]; // 标记点是否在队列里

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;
}

int spfa()
{
    queue<int> q;
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    q.push(1);
    bt[1] = true;
    
    while(q.size())
    {
        int t = q.front();
        q.pop(), st[t] = false; // 从队列出去的点就标记为false,表示如果该点被更新发生变化之后可以再次入队
        
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                 if (!bt[j]) // 已经在队列里面的点就不用再进去了
                {
                    q.push(j);
                    bt[j] = true;
                }
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    memset(h, -1, sizeof h);
    
	cin >> n >> m;
    int a, b, c;
    for (int i = 1; i <= m; i ++)
    {
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    if (spfa() == -1) puts("impossible");
    else cout << spfa() << endl;
    
    return 0;
}
~~~

另外spfa算法还可以用来判断是否存在负环：

~~~c++
string spfa()
{
    memset(h, -1, sizeof h);
    queue<int> q;
    
    memset(dist, 0x3f, sizeof dist); // 为何去掉对dist的初始化也能得出正确答案。
    dist[1] = 0;
    
    for (int i = 1; i <= n; i ++)
        q.push(i), bt[i] = true;

    while(q.size())
    {
        int t = q.front();
        q.pop(), bt[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            
            if (dist[j] > dist[t] + w[i])
            {
                cnt[j] = cnt[t] + 1;
                
                if (cnt[j] >= n) return "Yes";
                
                dist[j] = dist[t] + w[i];
                if (!bt[j])
                {
                    q.push(j);
                    bt[j] = true;
                }
            }
        }
    }
    return "No";
}
~~~

思路是增加一个cnt数组，在求最短路的时候记录每个点的最短路经由几条边。如果大于等于 n 的话，就说明存在负环。

### floyd算法

多源汇最短路。k 个询问，每次询问输入两个点，输出这两点的最短距离。

~~~c++
#include<iostream>
#include<cstring>

using namespace std;

const int N = 207, M = 2e4 + 7, INF = 1e9;
int n, m, k;
int arr[N][N]; // 稠密图用邻接矩阵来存储边

// 基于动态规划。
void floyd()
{
    for (int k = 1; k <= n; k ++)
        for (int i = 1; i <= n; i ++)
            for (int j = 1; j <= n; j ++)
                arr[i][j] = min(arr[i][j], arr[i][k] + arr[k][j]);
}

int main()
{
    cin >> n >> m >> k;
    
    // 初始化！
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= n; j ++)
            if (i == j) arr[i][j] = 0;
            else arr[i][j] = INF;
    
    // 边的输入
    int a, b, c;
    for (int i = 1; i <= m; i ++)
    {
        scanf("%d%d%d", &a, &b, &c);
        arr[a][b] = min(arr[a][b], c);
    }
    
    floyd();
    
    while(k --)
    {
        int a, b;
        scanf("%d%d", &a, &b);
        if (arr[a][b] > INF / 2) puts("impossible"); // 可能到不了 n 点，但是被负权边更新，就会小于INF
        else cout << arr[a][b] << endl;
    }
    
    return 0;
}
~~~

## 贪心

### 区间问题

#### 1 区间选点

首先提一嘴区间问题大都需要以区间的左或右端点来排序。然后进行操作。

这个的思路是以区间右端点为关键字来排序，然后遍历。

~~~c++
#include<iostream>
using namespace std;
const int N = 1e5 + 7;
struct internal
{
    int l, r;
    bool operator<(const internal &t)const
    {
        return r < t.r;
    }
}a[N];
int main()
{
	
}
~~~



## 字符串

### BM算法求主串中是否存在一个模式串：

### 大名鼎鼎的KMP

~~~c++
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = -1;
        next[0] = j;
        for(int i = 1; i < s.size(); i++) { // 注意i从1开始
            while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
                j = next[j]; // 向前回溯
            }
            if (s[i] == s[j + 1]) { // 找到相同的前后缀
                j++;
            }
            next[i] = j; // 将j（前缀的长度）赋给next[i]
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()] = {0};
        getNext(next, needle);
        int j = -1; // // 因为next数组里记录的起始位置为-1
        for (int i = 0; i < haystack.size(); i++) { // 注意i就从0开始
            while(j >= 0 && haystack[i] != needle[j + 1]) { // 不匹配
                j = next[j]; // j 寻找之前匹配的位置
            }
            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动 
                if (++ j == (needle.size() - 1) ) return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
~~~



### 求字符串最大公共子串的长度：

1：暴力：

~~~c++
#include<iostream>
#include<cstdio>
#include<cstring> 

using namespace std;

const int N = 1007;
char str1[N], str2[N];
int n, m;
int ans = 0;

int f(const char *s1, const char * s2)
{
	int arr[N][N] = {0};
	int len1 = strlen(s1);
	int len2 = strlen(s2);
	int i, j;
	
	int Max = 0;
	for (i = 1; i <= len1; i ++)
	{
		for (j = 1; j <= len2; j ++)
		{
			if (s1[i - 1] == s2[j - 1]) arr[i][j] = arr[i - 1][j - 1] + 1, Max = max(Max, arr[i][j]);
		}
	}
	return Max;
}

int main()
{
	cin >> str1 >> str2;
	ans = f(str2, str1);
	cout << ans << endl;
	return 0;
}
~~~

## 极客时间

### 1：红黑树

红黑树是一种平衡二叉查找树，为了解决普通二叉查找树在数据更新中，复杂度退化的问题而产生的。红黑树的高度近似log2(n),近似平衡，插入删除查找工作的时间复杂度都是log(n)。



## 计算机知识

### c++关键字

#### virtual

virtual可以声明虚函数和纯虚函数。

- 1、纯虚函数声明如下： **virtual void funtion1()=0;** 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。

- 2、虚函数声明如下：**virtual ReturnType FunctionName(Parameter)** 虚函数必须实现，如果不实现，编译器将报错，错误提示为：

    ```
    error LNK****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"
    ```

- 3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。

- 4、实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。

- 5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。

- 6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。

- 7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。

- 8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

#### static

在面向过程编程中，static可以修饰：全局变量、局部变量、函数。分别叫静态全局变量、静态局部变量、以及静态函数。

为什么static成员一定要在类外初始化?
这是因为被static声明的类静态数据成员，其实体远在main()函数开始之前就已经在全局数据段中诞生了！其生命期和类对象是异步的，（而且静态语意说明即使没有类实体的存在,其静态数据成员的实体也是存在的）这个时候对象的生命期还没有开始，如果你要到类中去初始化类静态数据成员,让静态数据成员的初始化依赖于类的实体,，那怎么满足前述静态语意呢?难道类永远不被实例化，我们就永远不能访问到被初始化的静态数据成员吗? 所以为了满足C++的static语意,static成员一定要在类外初始化!

~~~c++
#include <iostream>

using namespace std;

// 未被初始化的静态变量会被自动赋值为0（char和string类型的数据会被初始化为空。）
static int n; // 静态全局变量不能被其它文件所用、其它文件中可以定义相同名字的变量，不会发生冲突；

void fn() {
    static int n = 1; // 静态局部变量：作用域外不可用，只会被初始化一次，之后再次调用这个变量时它的值还是上次调用时候的值。
	cout << n ++ << endl; // main()函数里面的三个fn()分别输出 1， 2， 3
    return ;
}

static void f() { // 静态函数不能被其它文件所用、其它文件中可以定义相同名字的函数，不会发生冲突。
    cout << "hello world!" << endl;
    return 0;
}

int main() {
	fn();
	fn();
    fn();
    return 0;
}
~~~

在面向对象编程中，static可以修饰：静态数据成员、静态成员函数。

类的静态数据成员和静态成员函数是一个类的所有对象共有的。不会像普通成员那样，每个对象都有。

静态成员函数只能访问静态成员变量以及静态成员函数。非静态成员函数可以任意地访问静态成员函数和静态数据成员。

#### mutable

adj: 易变的

在成员函数中如果不想让外界改变类内变量，可以加一个const关键字，而有时候有一些变量，希望在这种情况下还是可变的，就可以加一个mutable关键字。

#### extern

exter可以修饰别的文件中的全局函数或者全局变量，而使得本文件可以使用被extern修饰的全局函数、变量。

#### friend

定义友元的关键字。

友元：包括友元类和友元函数。即，为了使其他类（函数）可以访问本类的私有和保护类型的数据。

友元函数的定义方法：

~~~c++
#include<iostream>
using namespace std;
class student{
private:
    string name = "";
    void print();
public:
    friend void prin(student stu);
    void set_name(string _name) {
        name = _name;
    }
};
void prin(student stu) {
    stu.print();
    return ;
}
void student::print() {
    cout << name;
}
int main() {
    student stu;
    stu.set_name("zhangxiaoquan");
    prin(stu);
    return 0;
}
~~~

友元类的定义方法：

~~~c++
#include<iostream>
using namespace std;
class student{
private:
    string name = "";
    void print();
public:
    friend class prin;
    void set_name(string _name) {
        name = _name;
    }
};
void student::print() {
    cout << "I'm a student!" << endl;
    return ;
}
class prin{
public:
    void print(student stu) {
        cout << stu.name << endl;
        stu.print();
    };
};
int main() {
    student stu;
    stu.set_name("zhangxiaoquan");
    prin pr;
    pr.print(stu);
    return 0;
}
~~~

#### volatile

易失性说明符是对编译器的一种提示，即对象可能会以语言未指定的方式更改其值，因此必须避免激进的优化。

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

### 模板



#### 普通模板

c++强类型的程序设计迫使我们为逻辑结构相同而具体数据类型不同的对象编写模式一致的代码，而无法抽取其中的共性，这样显然不利于程序的扩充和维护。c++模板应运而生。

~~~c++
#include<iostream>

using namespace std;

template<class T>
void Swap(T& a, T&b) {
    T c = a;
    a = b;
    b = c;
}
template<class T>
class student{
public:
    T a;
    student(T _a) : a(_a){}
};

int main() {
    int a = 1, b = 0;
    Swap<int>(a, b);
    cout << a << ' ' << b << endl;
    student<int> stu(1.23);
    cout << stu.a << endl;
    return 0;
}
~~~

#### 模板的特化：

有时候针对特殊的情况需要对模板进行特殊处理，比如一下的这种情况：

~~~c++
#include <iostream>
using namespace std;

template <class T>
class TClass
{
public:
     bool Equal(const T& arg, const T& arg1);
};

template <class T>
bool TClass<T>::Equal(const T& arg, const T& arg1)
{
     return (arg == arg1);
}

int main()
{
     TClass<int> obj;
     cout<<obj.Equal(2, 2)<<endl;
     cout<<obj.Equal(2, 4)<<endl;
}
~~~

对于double和float类型的判等，当然不能进行简单的 ==。下面是对与模板的特化：


~~~c++
#include <iostream>
using namespace std;
#include<cmath>

template <class T>
class Compare {
public:
    bool Equal(const T& arg, const T& arg1);
};

template<>
class Compare<double> {
public:
    bool Equal(const double& arg, const double& arg1);
};

template<class T>
bool Compare<T>::Equal(const T& arg, const T& arg1) {
    cout << "T == T" << endl;
    return arg == arg1;
}

bool Compare<double>::Equal(const double& arg, const double& arg1) {
    cout << "double == double" << endl;
    return (fabs(arg - arg1) <= 10e-6);
}

int main() {
    Compare<int>C;
    cout << C.Equal(3, 3) << endl;
    Compare<double>D;
    cout << D.Equal(3.1, 3.1) << endl;
    // cout << -1e3 << ' ' << 1e-5 << endl;
    return 0;
}
~~~

#### 模板的偏特化

与模板特化的区别在于，模板特化以后，实际上其本身已经不是templatized，而偏特化，仍然带有templatized。我们来看一个实际的例子：

~~~c++
#include <iostream>
using namespace std;

// 一般化设计
template <class T, class T1>
class TestClass
{
public:
     TestClass()
     {
          cout<<"T, T1"<<endl;
     }
};

// 针对普通指针的偏特化设计
template <class T, class T1>
class TestClass<T*, T1*>
{
public:
     TestClass()
     {
          cout<<"T*, T1*"<<endl;
     }
};

// 针对const指针的偏特化设计
template <class T, class T1>
class TestClass<const T*, T1*>
{
public:
     TestClass()
     {
          cout<<"const T*, T1*"<<endl;
     }
};

int main()
{
     TestClass<int, char> obj;
     TestClass<int *, char *> obj1;
     TestClass<const int *, char *> obj2;

     return 0;
}
~~~



### 编译器和解释器的区别

~~~c++
一、编译器和解释器的区别
1.编译器：将源代码直接编译成目标平台的机器码，即可执行代码。运行过程中不需要依赖编译器。
2.解释器：逐行解释源代码，并转化成对应的目标平台的机器码执行。在运行过程中需要依赖解释器。
    
二、解释型语言和编译型语言
1.编译型：在运行前，编译器将源代码生成目标平台的可执行代码，运行时不需要依赖编译器。如c/c++
2.解释型：在运行时，通过解释器解析源代码执行程序。运行过程中依赖解释器。
    
三、现在主流语言的执行方式
由于解释器逐行解释源代码太慢，很多高级语言对运行方式进行了优化，主要有三种运行方式：
1.纯解释器：运行时直接解释源代码。如shell语言。
2.预编译+解释器：运行前将源代码预编译成一些有效率的字节码，在运行时由解释器解释并执行字节码。如python语言。
3.预编译+解释器+及时编译(JIT)：也就是所谓的虚拟机形式。运行前将源代码预编译成一些有效率的字节码，在运行时由解释器解释并执行字节码。为了提高执行效率，虚拟机会在运行过程对频繁执行的方法进行优化，把它编译成本地码（也就是对应的机器码），这样就不需要频繁解释了。如Java语言。这种在在运行过程中进行编译的方式叫做JIT。由于这种执行方式存在编译过程，所以有人把这样执行的语言也叫作编译语言。
4.要注意的是：编译器是运行前进行编译，JIT是在运行过程中进行编译。为了区分，大家把运行前的编译称为静态编译，运行过程中的编译称为动态编译。
~~~



### 变量左右移

移位运算包括两种：

	逻辑移位：移出去的位丢弃，空缺位补零。
	
	算术移位：移出去的位丢弃，空缺位用符号位补。所以一般用在右移操作上。

无符号数通通采用逻辑移位。

负数转换为无符号数时，是将复数的补码直接作为转换后的值

负数在左移的时候符号位不会移动，但是当数值位的值全部移走之后符号位上的值也会移走，最后变成0。

正数在左移的时候，当数值位上的 1 移动到符号位上的时会变成负数，一直移动的结果也是变成0。

负数在进行异或操作时候符号位也会进行异或操作。

### c++的三种访问权限

C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是你能不能使用该类中的成员。

> Java、C# 程序员注意，C++ 中的 public、private、protected 只能修饰类的成员，不能修饰类，C++中的类没有共有私有之分。

在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。

在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。protected属性的成员可以被类的子孙类访问，而private属性的成员则不可以。

### c++模式

工厂模式：

简单工厂模式：

定义一个工厂类，它可以根据不同的参数创建并返回不同的类，其中这些类具有一个公共的父类或是一个接口。

产品类需要有一个基类，基类中的具体产品实现需要时一个纯虚函数，在子类中必须要重写具体的产品实现，以此实现不同的功能。

这里所有的产品（+*）需要有一个基类(Product)，产品类封装完成后，还需要一个工厂类，工厂类对产品类再次封装，最终实现**由一个工厂对象决定创建出哪一种产品类的实例**。

~~~c++
//简单工厂模式
#include<iostream>
using namespace std;

//产品的基类
class Product{
public:
   //基类中的纯虚函数
	virtual int operation(int a, int b) = 0;
};
//产品的子类Add
class Product_Add : public Product{
public:
	int operation(int a, int b){
		return a + b;
	}
};
//产品的子类Mul
class Product_Mul : public Product{
public:
	int operation(int a, int b){
		return a * b;
	}
};
//工厂
class Factory{
public:
	Product* Create(int i){
		switch (i){
		case 1:
			return new Product_Add;
			break;
		case 2:
			return new Product_Mul;
			break;
		default:
			break;
		}
	}
};

int main()
{
	Factory *factory = new Factory();
	int add_result = factory->Create(1)->operation(1, 2);
	int mul_result = factory->Create(2)->operation(1, 2);
	cout <<"op_add：" <<add_result << endl;
	cout <<"op_multiply：" << mul_result << endl;
		getchar();
	return 0;
}
// 原文链接：https://blog.csdn.net/chaipp0607/article/details/100107319
~~~

上面的代码中实现了两个产品，一个“加”，一个“乘”，选择哪一种操作完全由工厂类封装的`Create()`来决定。
但是简单工厂模式违背开放-封闭原则，即对扩展开放，对修改封闭。因为要添加第三个产品“减”时，需要修改工厂类的代码。

工厂方法模式：

每一个产品都有一个工厂，新增一个产品时候就新增一个工厂，工厂和产品都有自己的基类。

~~~c++
#include<iostream>

using namespace std;

//工厂方法模式
class Product{
public:
	virtual int operation(int a, int b) = 0;
};

class Product_Add : public Product{
public:
	int operation(int a, int b){
		return a + b;
	}
};

class Product_Mul : public Product{
public:
	int operation(int a, int b){
		return a * b;
	}
};

class Factory{
public:
	virtual Product* Create() = 0;
};


class Factory_Add : public Factory{
public:
	Product* Create(){
		return new Product_Add;
	}
};

class Factory_Mul : public Factory{
public:
	Product* Create(){
		return new Product_Mul;
	}
};

int main()
{
	Factory_Add *factory_add = new Factory_Add();
	Factory_Mul *factory_mul = new Factory_Mul();
	int add_result = factory_add->Create()->operation(1, 2);
	int mul_result = factory_mul->Create()->operation(1, 2);
	cout << "op_add：" << add_result << endl;
	cout << "op_multiply：" << mul_result << endl;
	getchar();
	return 0;
}
// 原文链接：https://blog.csdn.net/chaipp0607/article/details/100107319
~~~

当增加一个新产品时，同时增加一个新工厂。增加新工厂属于扩展，不会修改以前工厂类和产品类的任何代码。

这是为了在新增功能的时候不触及之前功能的代码。

抽象工厂模式：

在工厂方法模式的基础上，如果一个工厂想要生产多个产品，就有了抽象工厂模式，抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。抽象工厂模式其实是简单工厂模式和工厂方法模式的组合。

~~~c++
#include<iostream>
using namespace std;

//抽象工厂模式
class Product_P{
public:
	virtual int operation(int a, int b) = 0;
};

class Product_Padd : public Product_P{
public:
	int operation(int a, int b){
		return abs(a) + abs(b);
	}
};

class Product_Pmul : public Product_P{
public:
	int operation(int a, int b){
		return abs(a) * abs(b);
		
	}
};

class Product_F{
public:
	virtual int operation(int a, int b) = 0;
};

class Product_Fadd : public Product_F{
public:
	int operation(int a, int b){
		return (-a) + (-b);
	}
};
class Product_Fmul : public Product_F{
public:
	int operation(int a, int b){
		return -(a*b);
	}
};

class Factory{
public:
	virtual Product_P* Create_P() = 0;
	virtual Product_F* Create_F() = 0;
};


class Factory_Add : public Factory{
public:
	  Product_Padd* Create_P(){
		return new Product_Padd;
	}
	Product_Fadd*  Create_F(){
		return new Product_Fadd;
	}
};

class Factory_Mul : public Factory{
public:
	Product_Pmul* Create_P(){
		return new Product_Pmul;
	}
	Product_Fmul* Create_F(){
		return new Product_Fmul;
	}
};

int main()
{
	Factory_Add *factory_add = new Factory_Add();
	Factory_Mul *factory_mul = new Factory_Mul();
	int p_add_result = factory_add->Create_P()->operation(1, 2);
	int p_mul_result = factory_mul->Create_P()->operation(1, 2);
	int f_add_result = factory_add->Create_F()->operation(1, 2);
	int f_mul_result = factory_mul->Create_F()->operation(1, 2);
	cout << "op_p_add：" << p_add_result << endl;
	cout << "op_p_multiply：" << p_mul_result << endl;
	cout << "op_f_add：" << f_add_result << endl;
	cout << "op_f_multiply：" << f_mul_result << endl;
	getchar();
	return 0;
}
// 原文链接：https://blog.csdn.net/chaipp0607/article/details/100107319、、
~~~

单例模式：

这种模式设计一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

**注意：**

- 1、单例类只能有一个实例。
- 2、单例类必须自己创建自己的唯一实例。
- 3、单例类必须给所有其他对象提供这一实例。

**应用实例：**

- 1、一个班级只有一个班主任。
- 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
- 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。

### 内存管理

常见的内存错误以及策略：

1：内存分配未成功，却使用了它。

常用的解决办法就是：在使用内存之前检查指针是否为NIULL。如果指针p是函数的参数，那么在函数的入口处用assert(p != NULL)进行检查。

2：内存虽然分配成功，但是尚未初始化就引用他。

犯这种错误的起因有两个：一是没有初始化的观念；二是误以为内存的缺省初值全为0，导致引用初值错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。

3：内存分配成功并且已经初始化，但是操作越过了内存的边界。

例如数组的下标经常容易出现多一或者少一的情况。

4：忘记释放内存导致内存泄露。

含有这种错误的函数每被调用一次就丢失一块内存。刚开始的时候系统内存重组，看不到错误。终有一次程序突然死掉，提示内存耗尽。

动态内存的申请与释放必须配对，程序中malloc和free的使用要成对，否则肯定有错误（new /delete同理）。

5：释放了内存却继续使用指向它。

有三种情况：

（1）：程序中的对象调用关系过于复杂，难以搞懂某个对象是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。

（2）：函数的返回对象写错了，注意不要返回指向栈内存的指针或引用，因为该内存在函数体结束时被自动销毁。

（3）：使用free或者delete释放了测i村后，没有江南指针设置为NULL。导致产生“野指针”。

【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。

【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。

【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。

【规则4】动态内存的申请与释放必须配对，防止内存泄漏。

【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。

为什么有了malloc和free还要new和delete？

对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，在消亡之前自动执行析构函数。malloc/free是库函数而不是运算符，不在编译器控制范围之内，不能将执行构造函数和析构函数的任务强加给mallco/free。

因此c++语言需要一个能完整动态内存分配和初始化工作的运算符new，以及一个能完整清理与释放内存工作的运算符delete。

既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。

### 指针和引用的关系：

~~~c++
int a = 3;
int* p = &a;
/p是一个指向int类型的指针，其内容是所指向内存的地址，且可指向其他内存，对p进行加减操作是内存的移动。
int& b = a;
// b是一块存放着a变量的栈内存区域，赋值之后内存区域就不可变了，对b进行操作就是对b内存内的变量进行操作。
int a = 7;
int *p = &a;
int*& c = p; // 表示引用一个int类型的指针，p里面存放着a的地址。
~~~

### c++源文件从文本到可执行文件经历的过程

共经历四个过程：

预处理阶段：对源代码文件中文件包含关系（头文件），以及预编译语句（宏定义）进行分析和替换，生成预编译文件。

编译阶段：将经过预处理后的预编译文件转化成相应的汇编代码，生成汇编文件。

汇编阶段：将汇编文件转化成机器码，生成可重定位目标文件。

连接阶段：将可重定位目标文件以及需要的库连接成最终的可执行目标文件。

### 头文件用 "" 和 <>包括的区别

双括号和尖括号的区别：编译器预处理阶段查找头文件的路径不同。

对于双引号包含的头文件，查找头文件的循序为：

当前头文件目录---编译器设置的头文件路径---系统变量指定的头文件路径

而尖括号不在当前头文件目录中查找。

### 红黑树的五个特性

1：节点为黑或红。

2：根节点为黑。

3：父子两节点不得同时为红。

4：任意节点到达NULL节点之任一路径，所包含的黑节点数量必须相同。

5：为求方便，视NULL节点为黑节点。

### fork函数

fork函数的作用，以及参数和返回值：	UNIX或者类UNIX中的分叉函数。fork函数用于创建一个新的进程，他与进程（调用fork函数的进程）同时运行。此进程成为父进程。fork函数不需要参数，有返回值： 若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；

产生的父子进程的关系：子进程拥有父进程的数据空间、堆、栈等资源的副本。这表明他们并不共享这些存储空间。

注意：UNIX将复制父进程的地址空间内容给子进程，因此子进程有独立的地址空间。但是我们无法确定fork()之后是父进程先运行，还是子进程先运行。这依赖于系统的实现。所以在一直代码时我们不应对此有任何假设。

### 字节序：最大端最小端

对于int a = 0x01234567如果在内存中是这样存储的：0 1 2 3 4 5 6 7（16进制）,这种最高有效字节在前的存储方式叫大端法

相反的叫小端法。

编程判断最大端最小端：

~~~c++
#include<iostream>

using namespace std;

union{
    short a;
    char str[sizeof(short)];
}u;

int main() {
    u.a = 0x0102;
    if (sizeof(u.str) == 2) {
        if (u.str[0] == 1 && u.str[1] == 2) cout << "---big---" << endl;
        else if (u.str[0] == 2 && u.str[1] == 1) cout << "---small---" << endl;
        else cout << "uncomon";
    } else {
        cout << "try again";
    }
    return 0;
}
~~~

### 多线程：

1：原子操作：不会被线程调度机制打断的操作，一经开始就一直运行到结束。

需要声明一个atomic的类，然后配合while（）使用。

~~~c++
class FooBar {
private:
    int n;
    atomic<bool> foo_done = false;
public:
    FooBar(int n) : n(n) {}

    void foo(function<void()> printFoo) {
        for (int i = 0; i < n; i++) {
            while (foo_done) {
                this_thread::yield();
            }
            printFoo();
            foo_done = true;
        }
    }

    void bar(function<void()> printBar) {
        for (int i = 0; i < n; i++) {
            while (!foo_done) {
                this_thread::yield();
            }
            printBar();
            foo_done = false;
        }
    }
};
~~~

2：互斥锁与条件变量：一般配合使用，互斥锁用来阻塞其他操作互斥变量的线程，而条件变量用来等待所需的资源的来临，并且在执行函数体之后，发出消息通知其他进程。

~~~c++
class FooBar {
private:
    int n;
    mutex mtx;
    condition_variable cv;
    bool foo_done = false;
public:
    FooBar(int n) : n(n) {}

    void foo(function<void()> printFoo) {
        for (int i = 0; i < n; i++) {
            unique_lock<mutex> lock(mtx);
            cv.wait(lock, [&]() { return !foo_done; });
            printFoo();
            foo_done = true;
            cv.notify_one();
        }
    }

    void bar(function<void()> printBar) {
        for (int i = 0; i < n; i++) {
            unique_lock<mutex> lock(mtx);
            cv.wait(lock, [&]() { return foo_done; });
            printBar();
            foo_done = false;
            cv.notify_one();
        }
    }
};
~~~

3：信号量：包含在<semaphore.h>文件中。

机制是等待信号量大于零的时候执行，执行完毕增加信号量。

~~~c++
#include <semaphore.h> // 需要手动包含信号量头文件

class FooBar {
private:
    int n;
    sem_t foo_done, bar_done;
public:
    FooBar(int n) : n(n) {
        sem_init(&foo_done, 0 , 0);
        sem_init(&bar_done, 0 , 1);
    }

    void foo(function<void()> printFoo) {
        for (int i = 0; i < n; i++) {
            sem_wait(&bar_done);
            printFoo();
            sem_post(&foo_done);
        }
    }

    void bar(function<void()> printBar) {
        for (int i = 0; i < n; i++) {
            sem_wait(&foo_done);
            printBar();
            sem_post(&bar_done);
        }
    }
};
~~~

### c++智能指针：

[C++ STL 四种智能指针_Dablelv的博客专栏-CSDN博客_智能指针](https://blog.csdn.net/K346K346/article/details/81478223)

智能指针用来智能的管理内存，智能指针所在的作用域结束之后，会自动地调用析构函数，满足一定条件后会释放所管理的对象内存。

1：unique_ptr:

 unique_ptr有普通指针的所有功能，在作用域结束之后会将内存释放。

特点：持有对对象的独有权，两个unique_ptr对象不能指向同一个对象。

~~~c++
#include<iostream>
#include<memory>
using namespace std;
int main() {
    auto p0 = make_unique<string>("1234");
    unique_ptr<string> p1(new string("123")); // 作用于结束之后，就会调用析构，释放所管理的对象。
    unique_ptr<string> p2;
    p2.reset(new string("123")); // 两种构造方法

    string *str = p2.release();
    p1 = nullptr; // 两种释放方法

    unique_ptr<string> p3(new string("234"));
    unique_ptr<string> p4 = move(p3); 
    p3.reset(p4.release());// 两种所有权转移
    
    if (p4.get() != nullptr) { // 判空操作，防止访问到为空的unique_ptr导致程序崩溃。
        
    }
    return 0;
}
~~~

2：shared_ptr：可以多个shared_ptr管理同一个对象，在所有shared_ptr超过作用域或者管理了其他对象的时候，被管理的对象才会被释放。适用于将对象指针用作函数参数以及返回值的时候。

~~~c++
#include<iostream>
#include<memory>

using namespace std;

int main() {
    int *a = new int(7);
    {
        shared_ptr<int>p1(a);
        weak_ptr<int>w(p1); // 用来监控p1
        cout << *p1 << ' ' << w.use_count() << endl; // 1
        {
            shared_ptr<int>p2(p1);
            cout << *p2 << ' ' << w.use_count() << endl; // 2
            {
                shared_ptr<int>p3(p2);
                cout << *p3 << ' ' << w.use_count() << endl; // 3
                p3.reset();
            }
        }
    }
    cout << *a << endl; // a占用的内存已经被释放
    return 0;
}
~~~

### cache缓存和buffer缓冲的区别：

cache是将常用的磁盘数据写入内存缓冲区，使用的时候不用去磁盘寻找了。

buffer是在向硬盘中写入数据的时候，将数据存入缓冲区，然后在一起向硬盘中写入。减少磁盘碎片和磁盘寻道次数。

### 中序表达式转换为后续表达式（逆波兰式）

1：构造运算符优先表，以及用来存储运算符的栈。

2：便利中序表达式。

3：遇到数字或者变量直接输出。如果栈为空，则将遍历到的运算符（  +，-， *， /，（， ...）压栈，栈不为空则执行规则4。

4：如果遍历到 '('，则直接入栈。如果遍历到')'，则输出栈顶元素，并将其弹出，直到遇见'('。

5：如果遍历到的运算符优先级高于栈顶元素，则直接入栈。否则将栈顶元素输出，并弹出。之后将遍历到的运算符压栈。

6：如果完成遍历之后，栈不空，则依次输出栈顶元素，并且弹出栈顶元素。

~~~c++
/**
 * 将中序表达式转化为后序表达式（逆波兰表达式）
 * 
 */ 
#include<iostream>
#include<stack>

using namespace std;

bool compare_operator(char a, char b) {
    if (b == '(') return true;
    if (a == '*' || a == '/') {
        if (b == '+' || b == '-') return true;
    }
    return false;
}

void translate(string str) {
    stack<char>s;
    for (int i = 0; i < str.size(); i ++) {
        if (str[i] >= 'a' && str[i] <= 'z') cout << str[i];
        else if (str[i] == '(') s.push(str[i]);
        else if (str[i] == ')') { // 如果遇到')'，则将栈顶数据输出并弹出，直到遇到'('，并将'('弹出。
            while (s.top() != '(') {
                cout << s.top();
                s.pop();
            }
            s.pop(); // 将'('弹出
        }
        else if (str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/') {
            if (s.empty() || compare_operator(str[i], s.top())) {
                s.push(str[i]); // 若栈空、当前运算符优先级大于栈顶元素，则入栈
            } else {
                cout << s.top();
                s.pop();
                s.push(str[i]);
            }
        }
    }
    while (!s.empty()) {
        cout << s.top();
        s.pop();
    }
    return ;
}

int main() {
    string str = "(a+b)*c+d+q*e";
    string ans = "";
    translate(str);
    return 0;
}


void translate(string str) {
    stack<char>s;
    for (int i = 0; i < str.size(); ++ i) {
        if ((str[i] >= '0' && str[i] <= '9') || (str[i] >= 'a' && str[i] <= 'z')) cout << str[i];
        else if (str[i] == '(') s.push(str[i]);
        else if (str[i] == ')') {
            while (s.top() != '(') {
                cout << s.top();
                s.pop();
            }
            s.pop(); // 弹出(
        } else if (str[i] == '+' || str[i] == '-' || str[i] == '*' || str[i] == '/') {
            if (s.empty() || compare(s.top(), str[i])) {
                s.push(str[i]);
            } else {
                cout << s.top();
                s.pop();
                s.push(str[i]);
            }
        }
    }
    while (!s.empty()) {
        cout << s.top();
        s.pop();
    }
}

~~~

### 用户态和内核态：

1：什么是用户态内核态：

用户态和内核态是两种执行权限。

用户态较之内核态有较低的执行权限，很多操作不被操作系统允许，原因简单来说就是用户态出现问题的时候，不能使操作系统也崩溃。

内核态相当于一个介于硬件与应用之间的层，内核有ring 0的权限，可以执行任何cpu指令，也可以引用任何内存地址，包括外围设备，例如硬盘网卡，权限等级最高。

在内存分配的时候，有一些内存是仅为内核态使用的。每个进程只允许访问自己申请到的内存，而且不允许访问外围设备。

2：状态转换

a：系统调用

这是用户态进程主动要求要求切换到内核态的一种方式。用户态进程通过调用申请使用操作系统提供的服务程序完成任务。比如fork()函数实质上就是执行了一个创建新进程的系统调用，而系统调用的机制，其核心还是使用了操作系统为用户特别开放的一个中断来实现的。

b：异常

当CPU在执行运行在用户态的程序时，发生了实现不可知的异常，这是会触发有当前运行进程切换到处理此类型的内核相关程序中，也就转到了内核态，比如缺页异常。

c：外围设备的中断

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要完成执行的指令，转而去执行与中断信号相对应的处理程序，如果先前执行的指令时用户态下的程序，那么这个转换过程自然也就发生了由用户态到内核态的切换，比如硬盘读写操作完成，系统切换到硬盘读写的中断处理程序种执行后续操作等。

### 深浅拷贝

浅拷贝指的是逐字节进行拷贝。但是一些有指针类型成员变量的类，在复制的时候不能进行浅拷贝。需要将内存空间申请一份，然后将待拷贝的数据复制过去，而不能直接将指针进行复制。否则会出现改变复件对象，原件对象也被改变的情况。



### GCC嵌入汇编代码的模板

GCC 支持嵌入汇编代码的模板，不同于其它 C 编译器支持嵌入汇编代码的方式，为了优化用户代码，GCC 设计了一种特有的嵌入方式，它规定了汇编代码嵌入的形式和嵌入汇编代码需要由哪几个部分组成，如下面代码所示。

~~~c++
__asm__ __volatile__(代码部分:输出部分列表: 输入部分列表:损坏部分列表);
~~~

### 线程引入的必要性

- 应用需要
    Web服务器:分派线程和工作线程可以同时工作
- 开销考虑
    进程的创建、撤销、通信、切换开销比较大，而线程的创建撤销，切换，通信（共享资源）开销小
- 性能考虑
    多个线程，计算线程，I/O线程各司其职，提高性能。

## 网络协议内容

### 1：HTTP和HTTPS

协议内容简介：

HTTP协议是超文本传输协议（Hyper Text Transfer Protocol）的缩写。是基于TCP协议的应用层传输协议。



HTTP协议中由于状态不持久化会带来一些问题，比如当前状态想要访问之前状态的信息，而有没有保存这个之前的信息。session可以保存这些信息，并对使得协议可以对其进行访问。



协议头部	：



协议中的请求方法：

## 设计模式

#### 访问者模式

对于基类的多个子类有很多种访问方法，不同的访问方法如果都写在原有的类中，会破坏其结构，也难以阅读。访问者模式要求在基类中有一个访问者基类，在访问者基类中有对各个子类的访问方法，基类中也有一个名叫accept的成员方法可以接受访问者类的指针，从而完成访问。